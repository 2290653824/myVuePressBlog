---
title: git三剑客
date: 2023-04-08 00:09:56
permalink: /pages/7c5934/
categories:
  - 其他
  - 开发工具
tags:
  - 
author: 
  name: xugaoyi
  link: https://github.com/xugaoyi
---

git add -u 仅仅添加已经被git追踪且跟新的

文件到咱存区，不会添加没有被跟踪的文件

git reset --hard

文件名字修改规范操作
之前的流程：
1. 将本地目录 mv fileName1 fileName2
2. 在暂存区 git rm fileName1
3. 将新文件加到暂存区 git add fileName2

git mv fileName1 fileName2 
可以不用进行add等

版本日志
git log
git log --oneline  以一行的形式显示日志
git log -n4    查看最新的n条日制
git log --graph  以地图的形式查看
git log --all   查看全部日志

git cat-file -t hash   查看hash 的类型
git cat-file -p hash  查看hash的具体信息

.git中四个重要的目录：
config 本地git配置信息
refs git中不同分之的信息
HEAD 当前使用的分支
objects 存放了tree等信息

git中的三个重要对象commit 、 tree、 blob

文件管理

![image-20230408114209684](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408114209684.png)

在Git中，commit、tree和blob是三个核心的对象类型，它们有着紧密的关系。

首先，blob（二进制大对象）是指文件的内容，它可以是任何类型的文件，包括源代码、图像、音频或视频等。每个blob在Git仓库中都有一个唯一的SHA-1哈希值来标识它。

其次，tree（树对象）是一种特殊的对象，它描述了一个目录的结构，包含一个或多个blob对象和其他tree对象，以及它们之间的关系。与blob一样，每个tree也有一个唯一的SHA-1哈希值。

最后，commit（提交对象）指向一个tree对象，并包含一些元数据，例如提交者、时间戳、提交消息等。当创建一个新的提交时，Git会创建一个新的commit对象并将其指向当前的tree对象。每个commit也有一个唯一的SHA-1哈希值。

因此，这三种对象类型的关系如下：一个commit对象指向一个tree对象，该tree对象描述了当前版本的目录结构，而该目录结构由一些blob对象组成，它们表示实际的文件内容。



一次commit对应着一个文件目录版本。一次commit会对应多个tree。一个tree相当于一个目录，tree下面也会对应多个tree或多个blob。一个blob相当于一个文件，在git中认为只要是文件内容相同，则认为是同一个blob



例如查看一个commit的详细信息：

git cat-file -p 4a4a8dea2a36bc3f476

![image-20230408120536680](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408120536680.png)

从里的tree我们都明白了，其实就是指向了一个文件。

但是这里的parent又是什么东西呢？

在 Git 中，每个提交记录都包含一个指向其父提交（或上一个提交）的指针。这些父提交可以是单个提交，也可以是多个提交，形成分支或合并历史记录。

在提交对象中，parent字段是一个指向一个或多个父提交的哈希值的列表。当创建一个新的提交时，Git 将会把当前的分支指向新的提交，同时将新的提交的 parent 字段设置为现有提交的哈希值。这样就形成了一系列有向无环图（DAG），用于表示代码库的历史版本。

**tree字段则指向该提交的根目录的哈希值**，表示这个提交所包含的文件和目录结构。通过跟踪 tree 和 parent 哈希值，Git 可以追溯整个代码库的历史记录，并允许用户查看先前的版本，比较更改和合并不同的历史记录。



问题：新建一个git仓库，有且仅有1个commit，仅仅包含/doc/readme，请问有多少个tree，多少个blob

![image-20230408141742391](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408141742391.png)



三大对象再理解

![image-20230412104615319](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412104615319.png)

这些对象都存在.git目录中的objects中

当我们进行clone或者push时，

![image-20230412105000394](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412105000394.png)



另外，如果更改一个文件的内容，只改变一点也会创建一个新的object，因为hash变了



需要细细研究，有点东西

https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247541766&idx=1&sn=8091a5f18aa7ede19557e2142637cf9a&chksm=e9c2c3f1deb54ae713eb48eb3e65e4a498df0ca0aca542cc4a971f261a0efe4aa79fff9e3bf9&mpshare=1&scene=23&srcid=0411xXR0BBftW5H0X098wgcm&sharer_sharetime=1681227533623&sharer_shareid=4d2ece652c18043ba9427f6fbfc02bc2#rd

首先我在创建一个结构目录如下的文件：

```shell
./git
doc
 - readme.txt
```

其中readme.txt的文件内容如下：

```java
hello world
```

现在我们将所有的文件进行提交，然后查看objects，目录下有哪些文件:

![image-20230412162638999](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412162638999.png)

如图新增了4个文件，根据之前的学习，我们猜测目录结构如下：

![image-20230412162821413](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412162821413.png)

使用git cat-file -p 命令查看hash的类型进行验证

```txt
git cat-file -p 2e9e6cd9fef232a6f0ecab0523718725b5bfdb24
040000 tree e7a75e980c7adc0d5ab1c49ecff082b518bb6cf8    doc

git cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad
hello world

git cat-file -p e7a75e980c7adc0d5ab1c49ecff082b518bb6cf8 
100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad    readme.txt

git cat-file -p f9843075fd6e4618f4c4081bce7cc9ce99986788
tree 2e9e6cd9fef232a6f0ecab0523718725b5bfdb24
author zj<XXX@qq.com> 1681285686 +0800
committer zj<XXX@qq.com> 1681285686 +0800

commmit message
```

(省略了-t 查看hash类型的操作，上面查询的是hash里的具体内容)

从上面这个我们就可以推测出下面的图示：

![image-20230412163359806](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412163359806.png)



以上就是我们第一次提交的内容，我们使用git log看看：

![image-20230412163441536](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412163441536.png)

如图，可以看出来日志内容中显示了commit对象的hash f9。



那么我们对readme文件进行修改，在最后一排添加一排111，然后进行提交到暂存区：

其实我们将文件添加到暂存区时，就已经会产生一个blob文件了，该文件就是新增了111的文件版本：

![image-20230412163942066](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412163942066.png)

那么我们将本次进行提交呢？

![image-20230412164308127](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412164308127.png)

其实就会发现会新增3个object，我们分别来看看每个object的内容

![image-20230412164802081](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412164802081.png)

![image-20230412164538149](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412164538149.png)

![image-20230412164614495](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412164614495.png)

根据上面我们又可以形成新的图示

![image-20230412165027767](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412165027767.png)

其实这么看差不多就理解了，当我们进行一次新的提交，因为应该了对应的文件readme，其会生成一个新的objectHash，而此时因为其hash变了，其当前目录为了记录历史记录，不得不生成一个新的tree来指向最新的文件，循环往复，直到最新的commit指向新建的tree。

可以得出一个结论，只要一个文件修改了，commit后，一定会产生新的commit和tree。而那些不变的文件，tree指向他们的原hash就可以。

例如我现在在doc下新建一个目录java，并在java下创建一个Main.java文件，commit后预期的结果应该如下所示：

![image-20230412165634272](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412165634272.png)

预期会增加5个节点。我们进行实际操作看看是不是呢？

![image-20230412165957583](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412165957583.png)

发现实际只增加了4个节点，很意外，我们看看每个hash的内容是什么

![image-20230412170513796](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412170513796.png)

发现缺少了提交的commit，怎么回事？我们看看git log

![image-20230412170748930](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412170748930.png)

其实看到了我们最新的提交a4开头。

这下我们就知道了，在/a4下面其实有两个文件，我们没有注意

![image-20230412170859918](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412170859918.png)

![image-20230412171037992](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412171037992.png)

这下就符合预期了，生成了5个节点是正确的。

![image-20230412171232647](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412171232647.png)

我们试试一个新的命令：git gc![image-20230412171557206](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412171557206.png)

此时我们在objects目录下看看，我们的hash不在了

![image-20230412171936478](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412171936478.png)

其实我们的东西跑到pack里面去了

![image-20230412172035120](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412172035120.png)

怎么查看pack的内容：

执行 git verify-pack -v 看下 idx 文件的内容：

![image-20230412172327528](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412172327528.png)

可以看到，我们所有的hash都压缩到这里了

//TODO : 后面跟着一长串的东西是什么 chain 



我们使用git gc时候，是不是和我们进行push时很相似，这一看就明白了：每次push时，其实会将我们本地在object中hash进行gc打包到pack中，下次我们clone下来时，服务端也会进行gc后再传输

![image-20230412173450453](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412173450453.png)

也就是说gc会对objects中的对象进行压缩。



在远程仓库中一般不会存储.git目录：

`.git` 目录是 Git 用来存储仓库的版本历史和元数据的目录，包含了 Git 所需的所有信息。该目录通常位于仓库的根目录中，但它被设计为隐藏目录，因此默认情况下不会在文件浏览器或终端窗口中显示。

虽然你可以在本地访问 `.git` 目录，但 GitHub 不会公开任何仓库的 `.git` 目录或其内容。GitHub 提供了 Git 命令行工具、API 和 Web 界面等多种途径来管理仓库和进行版本控制。



`git gc` 主要有以下作用：

1. 清理无用的对象。Git 会自动引用（reference）一些对象，例如最新的提交对象和分支头等，但是有些对象可能已经不再被引用，也就是所谓的无用对象。`git gc` 可以帮助我们找到并删除这些无用的对象，从而释放磁盘空间。
2. 压缩对象。Git 中的对象通常以松散格式存储，这样可以方便地添加和修改，但同时会占用更多的磁盘空间和读写时间。`git gc` 可以把松散格式对象压缩成紧凑格式，从而进一步减少磁盘占用，并提高读写性能。
3. 优化仓库。`git gc` 还会执行其他一些优化操作，例如压缩历史记录、删除冗余数据等，从而提高 Git 仓库的整体性能。

需要注意的是，`git gc` 命令可能需要一些时间来完成，特别是对于大型仓库来说。此外，建议不要频繁地手动执行 `git gc`，因为这可能会影响你的工作流程和 Git 的性能。通常情况下，我们可以让 Git 在满足一定条件时自动运行 `git gc`。





什么是git中的分离头指针：

![image-20230408154444722](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408154444722.png)

HEAD detached at hash

Git的分离头指针（Detached HEAD）是指当前工作树（Working Tree）处于HEAD指针指向的提交（Commit）之外的一种状态。在分离头指针状态下，Git不再跟踪分支（Branch）而是直接跟踪提交。

使用`git checkout <commit>`命令切换到一个特定的提交时，就会进入分离头指针状态。这种情况通常发生在以下几种情况：

1. 执行`git checkout <tag>`或`git checkout <commit hash>`等命令，但未创建新的分支来跟踪这个提交；
2. 在某个分支上进行修改，但在提交这些修改前执行了`git checkout <commit>`命令。

如果在分离头指针状态下进行修改并提交，那么这些提交将会成为孤立的提交（Orphan Commits），也就是没有任何分支指向的提交。



怎么产生？

git checkout commitHash

这时就产生了分离头指针，改指针并没有与任何的分支进行关联，当然我们可以在这里进行提交，但是因为没有任何分支进行关联，当我们突然切换到另一个分支过后，分离头指针上提交的commit就会丢失

那么分离头指针就完全没有用了吗？

分离头指针的优点是：

1. 可以方便地查看、修改、测试历史提交，无需创建新的分支或拉取代码；
2. 可以快速切换到不同的提交和版本，方便进行版本回退；
3. 可以在不影响当前分支的情况下修改和提交代码。

分离头指针的缺点是：

1. 在分离头指针状态下进行修改并提交，这些提交将成为孤立的提交，没有任何分支指向它们，可能会导致难以维护的仓库历史；
2. 分离头指针状态下，无法使用`git pull`等命令自动获取最新的远程更新；
3. 当需要继续开发时，需要创建新的分支来跟踪当前的工作，否则会丢失之前的提交记录。

因此，在实际应用中，建议尽量避免使用分离头指针状态，只有在特殊情况下才使用。



HEAD与Branch

正常情况下HEAD中保存的数据是一个地址的引用。

从目录的ref来看，其实真实指向的是一个commit，所以最总一个head不是指向多个commit，而是指向一个具体的commit。而这个commit有父亲节点可以访问，就间接的包含了多个commit

既然HEAD和branch本质上都指向了commit，其实我们的所有操作基本上都是基于commit进行操作，比如对比两侧commit的差异：

git diff commit1 commit2

git diff HEAD HEAD^

Git diff HEAD HEAD^^

git diff HEAD HEAD~2



怎么删除不需要的分支

检测删除（可能检测是否需要合并）git branch -d 分支名

强制删除 git branch -D 分支名



修改已提交的commit的message

git commit -amend 对最近一次提交作出变更

![image-20230408161121477](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408161121477.png)



对旧的commit进行变更

git rebase -i commithash的父亲

rebase是基于的意思，我们要修改commit1，那么我们要在commit1的父节点来进行修改commit2

![image-20230408162942375](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408162942375.png)

需要进行实战commit message进行修改

首先最基本的就是应该知道git rebase到底有什么用

①目前看看项目中的git日志

![image-20230409012918100](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409012918100.png)

②我们现在要把00eebc1 的commit信息改为second

git rebase -i be58967 (注意，这里我们需要rebase想要更改的commit的父commit)

![image-20230409013450069](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409013450069.png)

从图上看出，真实有效的为第一行，其他的都是help注释，这里我们将pick改为reword来更改message

保存退出后，会自动跳转到下面的界面，我们将对应的数据更改为second就可以了

![image-20230409013533013](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409013533013.png)



可以看见更改成功了

![image-20230409013612048](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409013612048.png)

注意，以上的变更一般在自己开发的分支上进行变更，在合作开发时，一般不要随意变更别人message



怎么把几个连续的commit变为一个commit

①选择需要合并commit的父commit作为rebase。

![image-20230409014942471](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409014942471.png)



如图所示，我想要合并2,3,4 那么我应该将first作为rebase

Git rebase -i be58967

②将要进行合并的分支选做squash命令

![image-20230409015722356](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409015722356.png)

③添加合并后的commit message

![image-20230409015840569](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409015840569.png)

合并成功·

![image-20230409015951181](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409015951181.png)

从上面可以看出来，似乎rebase操作都会涉及到**分离头指针**

看到上面的，合并后的commit相当于生成了一个新的commitHash，而最新的节点commit因为其父节点变化了，所以自己也产生了一个新的commithash,所以才会出现updated refs/heads/main，就是因为分支main指向的节点已经变化了。



怎么把几个间隔的commit变成一个comomit

![image-20230409023057138](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409023057138.png)

如图所示，我想将first合并到fifth分支，该怎么做了。我们之前说了rebase要有一个根基，但是现在first父节点我们是没有的该怎么办？

- 复制first的hash，然后在rebase -i中进行添加

![image-20230409023422335](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409023422335.png)

如图所示，我们手动添加了第一行commit。



现在我们要将first合并到fifth应该怎么做了？

![image-20230409023614781](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409023614781.png)

若果有冲突解决冲突，然后填写新commit的message

![image-20230409023837990](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409023837990.png)



保存退出即可:

![image-20230409023908863](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409023908863.png)

当您使用 git rebase 命令合并多个 commit 时，实际上是修改了本地的 Git 历史记录。如果此时直接使用 git push 命令将修改推送到远程仓库，那么 Git 会拒绝此操作，提示 “non-fast-forward” 错误。

这是因为 Git 的默认行为是只允许进行 fast-forward 合并，也就是只允许在原有基础上新增提交，而不允许强制覆盖历史记录。如果要将修改推送到远程仓库，需要使用 git push --force 或 git push -f 命令。

然而，强制推送可能会导致潜在的问题，如意外覆盖他人提交、丢失历史记录等，所以在进行强制推送前，请确保您已经充分理解其风险，并谨慎操作。

另一种更安全的方法是使用 git push --force-with-lease 命令。该命令会先检查远程仓库的状态，确保没有其他人在您之前推送过修改，然后再进行强制推送。这可以避免意外覆盖他人提交的风险。



怎么对比暂存区与已经提交的版本之间的差异

git diff --cached

怎么对比工作区与暂存区之间的差异

git diff

只针对某一个文件

git diff -- fileName1 fileName2



撤销暂存区

git reset Head -- filename1 filename2

Git reset HEAD 撤销全部



撤销工作区

git checkout -- filename1 filename2



删除最近的几次commit

git reset --hard hash





看几次commit之间的差异

git diff commt1 commit2 -- file



删除文件姿势

git rm file

也会自动将工作区的进行文件删除



git stash pop /apply 区别



指定不需要纳入git的文件

.gitignore





## 标签详解

https://juejin.cn/post/6844904130977202190



## 标签的本质

标签的本质是一次commit，其指向了一个commit对象。它们的值都为各自指向提交的`SHA1`值；但是，不同于会随着提交的变化而变化的分支，一旦给某次提交添加了标签，该标签就永远不会发生变化。

标签是一次提交，本次提交可以指向任何分支上的一次提交，且标签定下后，不会再进行改变。



## 标签的分类

- **轻量级标签**（`lightweight`）：不可添加注释；
- **带有附注的标签**（`annotated`）：可以添加注释；

> Annotated tags are meant for release while lightweight tags are meant for private or temporary object labels.

以上是`git`官方文档对两种标签的说明，大意是：带注释的标签用于发布，而轻量级标签则用于私人或临时对象。



## 标签何时使用



- 版本发布：一般`master`分支都会作为项目的发布分支，当项目开发到了一个成熟的阶段，准备在`master`分支进行发布时。一般都会在`master`分支的当前提交上打上一个类似"`v1.2`"的标签；
- 版本管理：可以通过标签的形式记录项目某一阶段的状态。

![image-20230412201509398](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412201509398.png)



## 标签相关命令

### 创建一个标签

- 轻量级标签

git tag 标签名

我们看看一个轻量级的标签的内容：

![image-20230412204829331](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412204829331.png)

这里很容易看出来，轻量级的tag内容就是commit。这说明什么

说明：轻量级标签就是代指了一个commit的指针！！它本身就是一个commit

- 带附注的标签

git tag -a 标签名 -m "注释"



创建好的标签文件存放在.git/refs/tags中

其实在git中tag也是一个对象，和commit、tree、blob一样

![image-20230412204232458](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412204232458.png)

我们看看这个tag的具体信息：

![image-20230412204331744](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412204331744.png)

**可以看到标签中有一个内容指向了具体的commit。**且带附注的tag的SAH1和其指向的SAH1不一致

说明带附注的标签更加重量级，他是一个tag对象，不是commit，只是其内部有指向commit的指针

### 显示标签

git tag 或者git tag --list



切换分支后，使用git tag依然可以展示标签，表示标签与tag是没有关系的



## 显示标签内容

git show 标签名





## 查找标签

支持正则表达式

 `git tag -l <tag_name>`





## 标签推送到远程

默认情况git push 是不会推送tag的。



推送特定的tag

`git push origin <tag_name>`



推送多个tag

`git push origin  v2.0 v3.0`



推送完整指令

`git push origin refs/tags/v4.0:refs/tags/v4.0`



推送本地全部的tag

 `git push origin --tag`



## 删除标签

#### 删除远程标签

当然，我们可以直接在远程仓库上删除远程标签。但是，最好的方式还是采用命令行进行删除。删除远程标签的方法与删除远程分支的方法非常类似，同样有两种方法：

 `git push origin :<tag_name>`

这种方法相当于推送一个空的标签到远程仓库，由此达到删除的效果。比如删除远程仓库中的标签`v3.0`：

```perl
git push origin :v3.0

```



![image-20200418154504982](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefined1718cc3c049ecef8~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png)



这样远程仓库中的标签`V3.0`就被删除了：



![image-20200418154554319](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefined1718cc3c05ba750d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png)



但是本地仓库中对应的标签`V3.0`并没有被删除：



![image-20200418154631370](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefined1718cc3c3a9cc162~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png)



上述指令为简写，**完整写法如下**：

```ruby
git push origin :refs/tags/v3.0

```



![image-20200418154906969](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefined1718cc3c3e6571bb~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png)



 `git push origin --delete <tag_name>`

该方法采用了更加语义化的参数`--delete`，实现远程标签的删除：

```perl
git push origin --delete v2.0

```



![image-20200418155134748](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefined1718cc3c3eef1019~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png)



同样成功地删除了远程仓库中的标签`v2.0`：



![image-20200418155216230](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefined1718cc3c400bbefd~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png)



但是，本地的标签`v2.0`也没有被删除：



![image-20200418155311429](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefined1718cc3c40587525~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png)



采用下列的完整写法，效果是一样的：

```perl
git push origin --delete tag v2.0

```



![image-20200418155513090](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefined1718cc3c416b78bc~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png)



> 不难发现，删除**远程分支**和**远程标签**的方法是**一样**的。

#### 删除本地标签

 `git tag -d <tag_name>`

如通过以下命令删除标签`v3.0`：

```
git tag -d v3.0
```

![image-20200418155616562](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefined1718cc3c666cfa53~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png)

## 标签的切换

类似于commit的切换，会产生分离头指针

`git checkout tag_name`

如图所示，在`master`分支上进行了三次提交，并且添加了相应的标签：



![image-20200418161353146](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefined1718cc3c6971af14~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png)



当我们通过`checkout`命令切换到标签`v2.0`时：



![image-20200418161526176](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefined1718cc3cadb6f5c8~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png)



可见，会出现游离的提交。此时查看各分支状态：



![image-20200418161655468](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefined1718cc3c6fb9fac7~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png)



如上图所示，当前处于标签`v2.0`指向的提交，并且切换标签的过程中改变了`HEAD`指针的指向。但是，并没有改变分支`master`的指向。过程如下图所示：



![image-20200418162458123](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefined1718cc3c7233c5bb~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png)



也就是说，切换标签与使用`reset`进行版本回退十分相似。只不过切换标签只改变了`HEAD`指针的指向，会造成游离的提交。若有需要可以创建一个新分支进行保存。

## 拉取标签

在下图所示的情况中，本地仓库`mygit`与远程仓库有公共的提交历史（同源），并且不发生合并冲突的情况下



![image-20200418160517111](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefined1718cc3c735807d7~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png)



可以直接通过`git pull`将远程仓库的标签拉取下来，并创建本地仓库中没有的标签：



![image-20200418160737829](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefined1718cc3c77f950e1~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png)





## git的作用域

git config 可以用来配置 Git 客户端的行为和属性。其作用域可以分为三种：

1. local：只对某个特定的仓库有效，设置在当前仓库的 .git/config 文件中。
2. global：对当前用户的所有仓库都有效，存储在当前用户根目录下的 .gitconfig 文件中。
3. system：对系统上所有登录用户的所有仓库都有效，通常存储在 /etc/gitconfig 文件中。

当同一个属性在多个配置文件中都有定义时，Git 会按照 local、global、system 的优先级依次查找并采用最后一个定义的值。

其中优先级别 local > global > system

### 二、`Git`别名

推荐日志别名：

```shell
[alias]
        lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit
        dog = log --all --decorate --oneline --graph
```



#### 1.设置`git`命令别名

 `git config <作用域> alias.<别名> '<命令>'`

`git config --global alias.dog 'log --all --decorate --oneline --graph'`

对应的信息会写入到对应作用域的配置文件里面



2. 设置外部命令别名

像`gitk`这样的外部命令，是没有`git`前缀的。设置别名的方法与设置`git`提供的命令有所不同，要按照如下格式设置：

##### `git config <作用域> alias.<别名> '<!外部命令>'`

- 感叹号表示这是一个外部命令；
- 注意要加上单引号，不用加`git`前缀；

比如在系统用户作用域下，将`git ui`设置为`gitk`的别名：

```csharp
 git config --global alias.ui '!gitk'
```

设置完成后，该配置会被写入系统用户的配置文件`gitconfig`中



设置了别名后，原来的命令依然有效

