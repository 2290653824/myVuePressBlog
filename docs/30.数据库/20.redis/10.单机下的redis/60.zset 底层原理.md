



## 一. zset使用方法

- [Redis](https://cloud.tencent.com/product/crs?from_column=20065&from=20065)有序集合`zset（sorted set）`与普通集合`set`非常相似，是一个**没有重复元素**的字符串集合。
- 不同之处是有序集合的每个成员都关联了一个`评分（score）`,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。**集合的成员是唯一的，但是评分可以是重复了 。**
- 因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。
- 访问有序集合的中间元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。

> 其实zset相对于redis的set，多出来得功能表现为score的排序功能，即插入到zset中带score的数据，会自动为我们进行排序。是不是很像java里的treeSet这类似堆，可以自动帮助我们进行排序。那么zset底层原理是什么呢？当使用一种存储结构时，我们就需要考虑其查询、插入更新等操作的时间空间复杂度，因此要知道底层的数据结构是怎么样的。



zset常见的应用场景：

延时队列、排行榜、限流等。具体可以参考：[读懂才会用：Redis ZSet 的几种使用场景](https://ost.51cto.com/posts/553)



## 二. zset底层原理

![img](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/6071fad6da235019ae832e0ba6169c31.png)

Zset它类似于 Java 中的 SortedSet 和 HashMap 的结合体，一方面它是一个 set 保证了内部 value 的唯一性，另一方面又可以给每个 value 赋予一个排序的权重值 score，来达到 排序 的目的。

底层的数据结构为 压缩列表+跳表来实现



### 压缩列表

- 首先讲一讲什么时候用压缩列表，什么时候用跳表。

> Redis的配置文件中关于有序集合底层实现的两个配置。
> 1、zset-max-ziplist-entries 128:zset采用压缩列表时，元素个数最大值。默认值为128。
> 2、zset-max-ziplist-value 64:zset采用压缩列表时，每个元素的字符串长度最大值。默认值为64。
>
> 当满足以下任一条件时，Redis便会将zset的底层实现由压缩列表转为跳跃表。
> 1、zset中元素个数大于zset_max_ziplist_entries；
> 2、插入元素的字符串长度大于zset_max_ziplist_value。
> zset在转为跳跃表之后，即使元素被逐渐删除，也不会重新转为压缩列表。
>
> 压缩列表ziplist本质上就是一个字节数组，是Redis为了节约内存而设计的一种线性数据结构，可以包含多个元素，每个元素可以是一个字节数组或一个整数。
>
> 因为ziplist是紧凑存储，没有冗余空间，意味着新插入元素，就需要扩展内存：
> 1、分配新的内存，将原数据拷贝到新内存； 
> 2、扩展原有内存;
> 所以ziplist 不适合存储大型字符串，存储的元素也不宜过多。

首先看看压缩列表长什么样：

ziplist 编码的 Zset 使用紧挨在一起的压缩列表节点来保存，第一个节点保存 member，第二个保存 score。ziplist 内的集合元素按 score 从小到大排序，其实质是一个双向链表。虽然元素是按 score 有序排序的， 但对 ziplist 的节点指针只能线性地移动，所以在 REDIS_ENCODING_ZIPLIST 编码的 Zset 中， **查找某个给定元素的复杂度为 O(N)**。

![image-20240120220405649](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20240120220405649.png)

压缩列表，占用内存比较少，但是对于数据的插入、查找等，非常耗时，所以只有在数据量很少的情况下，才会使用压缩列表。



### 跳表

下面介绍一下跳表

### ①跳表节点

首先看看跳表节点：

```
typedef struct zskiplistNode {
    robj *obj;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned int span;
    } level[];
} zskiplistNode;

typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;
```

-  `zskiplistNode` 结构体表示跳跃表中的一个节点，包含元素对象（`obj`）、分数（`score`）、指向前一个节点的指针（`backward`）和一个包含多个层的数组（`level`）。每一层都包含一个指向下一个节点的指针（`forward`）和一个表示当前节点到下一个节点的跨度（`span`）。 
-  `zskiplist` 结构体表示一个跳跃表，包含头节点（`header`）、尾节点（`tail`）、跳跃表中的节点数量（`length`）和当前跳跃表的最大层数（`level`）。



#### ②插入节点

插入的时间复杂度为O(logn)，每次插入都会先查找到要插入的位置（查找的时间复杂度就已经是【O(logn)】了，找到后直接插入【O(1)】，所以总的为【O(logn)】），删除也是同理为O(logn)

每个节点的插入层次是通过getRandomLevel()随机出来的，插入层次互不影响 以下模拟节点插入：

![img](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/format,png.png)

从上面skiplist的创建和插入过程可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。实际上，这是skiplist的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案。 skiplist，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。

#### ③查找

查找节点时，从高索引层往低索引层查找： 一开始元素在高层从链表由前往后查找，直到要查找的目标元素在该层的某两个相邻元素之间，就会往下跳到下层的同一个位置，继续从同一位置向链表尾方向遍历查询->重复上面的过程，直到查找到目标元素 查找时每一层都跳过部分元素，进而加快了查找效率，以下模拟节点查找：

![skiplist上的查找路径展示](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/format,png-20240120224913514.png)



#### ④随机层数level

执行插入操作时计算随机数的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：

首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。 如果一个节点有第i层(i>=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。 节点最大的层数不允许超过一个最大值，记为MaxLevel。 这个计算随机层数的伪码如下所示：

randomLevel() level := 1 // random()返回一个[0...1)的随机数 while random() < p and level < MaxLevel do level := level + 1 return level

randomLevel()的伪码中包含两个参数，一个是p，一个是MaxLevel。在Redis的skiplist实现中，这两个参数的取值为：

p = 1/4 MaxLevel = 32

产生节点的高度。使用抛硬币

```
 private int getRandomLevel() {
 //可知，元素的插入层次i从1开始自增，随机到哪一层的概率就像抛硬币一样，都是50%，故i越往后，其概率越小(每次都*0.5)
 //第一层概率：0.5，第二层0.5*0.5=0.25，...
    int lev = 1;
    while (random.nextInt() % 2 == 0) {
        lev++;
    }
    //MAX_LEVEL为跳表的最大层级
    return lev > MAX_LEVEL ? MAX_LEVEL : lev;
}
```







#### ⑤跳表特点

跳表的最底层拥有所有的元素

跳表每一层都是一个链表，除了最底层是原始链表，层次逐渐往上可分别划分为一级索引层、二级索引层...

跳表插入元素时，会先随机生成出一个“层次数字”，然后元素会插入到这个层次的所有底层，直到原始链表层

如果一个元素存在与某个索引层，那么这个元素也会存在于低于它的所有索引下层，如元素在第99索引层，那么由上到下从99索引层直到原始链表层都会存在该元素

空间换时间，跳表查找变快了，但是要存储许多索引层，故空间开销变大了





## 三. zset为什么使用跳表而不是用b+树

因为 zset 要支持随机的 插入 和 删除，所以它 不宜使用数组来实现，关于排序问题，我们也很容易就想到 红黑树/平衡树 这样的树形结构，为什么 Redis 不使用这样一些结构呢？

1. 性能考虑：在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部
2. 实现考虑：在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观；

　　基于以上的一些考虑，Redis 基于 **William Pugh** 的论文做出一些改进后采用了 **跳跃表** 这样的结构。



[MySQL](https://cloud.tencent.com/product/cdb?from_column=20065&from=20065) 的 B+ 树和 Redis 的跳表都是用于存储有序数据的数据结构，但它们有一些关键的区别，使得它们在不同的场景和用途中各有优势。

1.  结构差异：B+ 树是一种多路搜索树，每个节点可以有多个子节点，而跳表是一种基于链表的数据结构，每个节点只有一个下一个节点，但可以有多个快速通道指向后面的节点。 
2.  空间利用率：B+ 树的磁盘读写操作是以页（通常是 4KB）为单位的，每个节点存储多个键值对，可以更好地利用磁盘空间，减少 I/O 操作。而跳表的空间利用率相对较低。 
3.  插入和删除操作：跳表的插入和删除操作相对简单，时间复杂度为 O(logN)，并且不需要像 B+ 树那样进行复杂的节点分裂和合并操作。 
4.  范围查询：B+ 树的所有叶子节点形成了一个有序链表，因此非常适合进行范围查询。而跳表虽然也可以进行范围查询，但效率相对较低。 

因此，B+ 树和跳表不能简单地相互替换。在需要大量进行磁盘 I/O 操作和范围查询的场景（如数据库索引）中，B+ 树可能是更好的选择。而在主要进行内存操作，且需要频繁进行插入和删除操作的场景（如 Redis）中，跳表可能更有优势。

Mysql 为什么使用 B +树，而不是跳表？

Mysql 数据库是持久化数据库，即是存储到磁盘上的，因此查询时要求更少磁盘 IO，且 Mysql 是读多写少的场景较多，显然 B+ 树更加适合M ysql。

Redis 的 ZSet 为什么使用跳表而不是B+树

Redis 是内存存储，不存在 IO 的瓶颈，所以跳表的层数的耗时可以忽略不计，而且插入数据时不需要开销以平衡数据结构（写多）。





## 四. 参考：
https://zhangtielei.com/posts/blog-redis-skiplist.html
https://blog.csdn.net/dingjianmin/article/details/121729149
https://www.cnblogs.com/liang1101/p/12984881.html

https://cloud.tencent.com/developer/article/2343216
https://blog.csdn.net/weixin_43871678/article/details/115163940

[跳表的详细操作](https://blog.csdn.net/qq_42604176/article/details/110550937)
