---
title: git三剑客
date: 2023-04-08 00:09:56
permalink: /pages/7c5934/
categories:
  - 其他
  - 开发工具
tags:
  - 
author: 
  name: xugaoyi
  link: https://github.com/xugaoyi
---

git add -u 仅仅添加已经被git追踪且跟新的文件到咱存区，不会添加没有被跟踪的文件

git reset --hard

文件名字修改规范操作
之前的流程：
1. 将本地目录 mv fileName1 fileName2
2. 在暂存区 git rm fileName1
3. 将新文件加到暂存区 git add fileName2

git mv fileName1 fileName2 
可以不用进行add等

版本日志
git log
git log --oneline  以一行的形式显示日志
git log -n4    查看最新的n条日制
git log --graph  以地图的形式查看
git log --all   查看全部日志

git cat-file -t hash   查看hash 的类型
git cat-file -p hash  查看hash的具体信息

.git中四个重要的目录：
config 本地git配置信息
refs git中不同分之的信息
HEAD 当前使用的分支
objects 存放了tree等信息

git中的三个重要对象commit 、 tree、 blob

文件管理

![image-20230408114209684](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408114209684.png)

在Git中，commit、tree和blob是三个核心的对象类型，它们有着紧密的关系。

首先，blob（二进制大对象）是指文件的内容，它可以是任何类型的文件，包括源代码、图像、音频或视频等。每个blob在Git仓库中都有一个唯一的SHA-1哈希值来标识它。

其次，tree（树对象）是一种特殊的对象，它描述了一个目录的结构，包含一个或多个blob对象和其他tree对象，以及它们之间的关系。与blob一样，每个tree也有一个唯一的SHA-1哈希值。

最后，commit（提交对象）指向一个tree对象，并包含一些元数据，例如提交者、时间戳、提交消息等。当创建一个新的提交时，Git会创建一个新的commit对象并将其指向当前的tree对象。每个commit也有一个唯一的SHA-1哈希值。

因此，这三种对象类型的关系如下：一个commit对象指向一个tree对象，该tree对象描述了当前版本的目录结构，而该目录结构由一些blob对象组成，它们表示实际的文件内容。



一次commit对应着一个文件目录版本。一次commit会对应多个tree。一个tree相当于一个目录，tree下面也会对应多个tree或多个blob。一个blob相当于一个文件，在git中认为只要是文件内容相同，则认为是同一个blob



例如查看一个commit的详细信息：

git cat-file -p 4a4a8dea2a36bc3f476

![image-20230408120536680](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408120536680.png)

从里的tree我们都明白了，其实就是指向了一个文件。

但是这里的parent又是什么东西呢？

在 Git 中，每个提交记录都包含一个指向其父提交（或上一个提交）的指针。这些父提交可以是单个提交，也可以是多个提交，形成分支或合并历史记录。

在提交对象中，parent字段是一个指向一个或多个父提交的哈希值的列表。当创建一个新的提交时，Git 将会把当前的分支指向新的提交，同时将新的提交的 parent 字段设置为现有提交的哈希值。这样就形成了一系列有向无环图（DAG），用于表示代码库的历史版本。

**tree字段则指向该提交的根目录的哈希值**，表示这个提交所包含的文件和目录结构。通过跟踪 tree 和 parent 哈希值，Git 可以追溯整个代码库的历史记录，并允许用户查看先前的版本，比较更改和合并不同的历史记录。



问题：新建一个git仓库，有且仅有1个commit，仅仅包含/doc/readme，请问有多少个tree，多少个blob

![image-20230408141742391](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408141742391.png)





什么是git中的分离头指针：

![image-20230408154444722](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408154444722.png)

HEAD detached at hash

Git的分离头指针（Detached HEAD）是指当前工作树（Working Tree）处于HEAD指针指向的提交（Commit）之外的一种状态。在分离头指针状态下，Git不再跟踪分支（Branch）而是直接跟踪提交。

使用`git checkout <commit>`命令切换到一个特定的提交时，就会进入分离头指针状态。这种情况通常发生在以下几种情况：

1. 执行`git checkout <tag>`或`git checkout <commit hash>`等命令，但未创建新的分支来跟踪这个提交；
2. 在某个分支上进行修改，但在提交这些修改前执行了`git checkout <commit>`命令。

如果在分离头指针状态下进行修改并提交，那么这些提交将会成为孤立的提交（Orphan Commits），也就是没有任何分支指向的提交。



怎么产生？

git checkout commitHash

这时就产生了分离头指针，改指针并没有与任何的分支进行关联，当然我们可以在这里进行提交，但是因为没有任何分支进行关联，当我们突然切换到另一个分支过后，分离头指针上提交的commit就会丢失

那么分离头指针就完全没有用了吗？

分离头指针的优点是：

1. 可以方便地查看、修改、测试历史提交，无需创建新的分支或拉取代码；
2. 可以快速切换到不同的提交和版本，方便进行版本回退；
3. 可以在不影响当前分支的情况下修改和提交代码。

分离头指针的缺点是：

1. 在分离头指针状态下进行修改并提交，这些提交将成为孤立的提交，没有任何分支指向它们，可能会导致难以维护的仓库历史；
2. 分离头指针状态下，无法使用`git pull`等命令自动获取最新的远程更新；
3. 当需要继续开发时，需要创建新的分支来跟踪当前的工作，否则会丢失之前的提交记录。

因此，在实际应用中，建议尽量避免使用分离头指针状态，只有在特殊情况下才使用。



HEAD与Branch

正常情况下HEAD中保存的数据是一个地址的引用。

从目录的ref来看，其实真实指向的是一个commit，所以最总一个head不是指向多个commit，而是指向一个具体的commit。而这个commit有父亲节点可以访问，就间接的包含了多个commit

既然HEAD和branch本质上都指向了commit，其实我们的所有操作基本上都是基于commit进行操作，比如对比两侧commit的差异：

git diff commit1 commit2

git diff HEAD HEAD^

Git diff HEAD HEAD^^

git diff HEAD HEAD~2



怎么删除不需要的分支

检测删除（可能检测是否需要合并）git branch -d 分支名

强制删除 git branch -D 分支名



修改已提交的commit的message

git commit -amend 对最近一次提交作出变更

![image-20230408161121477](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408161121477.png)



对旧的commit进行变更

git rebase -i commithash的父亲

rebase是基于的意思，我们要修改commit1，那么我们要在commit1的父节点来进行修改commit2

![image-20230408162942375](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408162942375.png)

需要尽心实战commit进行修改
