---
title: 并发基础
date: 2022-12-26 12:05:45
permalink: /pages/e7fe01/
categories:
  - java进阶
  - 并发编程
tags:
  -
author: 
  name: xugaoyi
  link: https://github.com/xugaoyi
---
### 并发编程三要素

- **原子性**：一系列操作同时成功或同时失败，一系列操作是不可分割的一部分。就拿线程来说，就是因为他们在程序运行的过程中，操作不是原子的，过程中可能有其他线程来访问共享变量，所以就可能造成并问题。

解决方案：

```java
通过 synchronized 关键字保证原子性。
通过 Lock保证原子性。
通过 CAS保证原子性。
```



- **可见性**：一个线程对共享变量修改，另一个线程能够立即看到这个共享变量的改变。

与JMM相关，线程工作内存的变量不能即是的刷回主存

如何保证可见性？

```java
通过 volatile 关键字保证可见性。
通过 内存屏障保证可见性。
通过 synchronized 关键字保证可见性。
通过 Lock保证可见性。
通过 final 关键字保证可见性
```

- **有序性**：程序的执行顺序按照代码的先后顺序执行。

编译器为了优化，改成程序指令的执行顺序。（本质：在单线程下尽力压榨cpu，但是多线程下会收到影响）

指令重排序有3种：

① **编译优化的重排序** 。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

② **指令级并行的重排序**。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。

③ **内存系统的重排序**。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上 去可能是在乱序执行。



重排序小案例：

重排序案例：单例模式的双重锁检验中，new关键字的重排序.

instance = new SingletonDclDemo(); 创建对象的代码，分为三步：① 分配内存空间；② 初始化对象SingletonDclDemo；③ 将内存空间的地址赋值给instance；

但是这三步经过重排之后：① 分配内存空间 ② 将内存空间的地址赋值给instance ③ 初始化对象SingletonDclDemo



如何保证有序性？

```java]
通过 volatile 关键字保证可见性。
通过 内存屏障保证可见性。
通过 synchronized关键字保证有序性。
通过 Lock保证有序性。
```





### 什么是JMM

JMM java虚拟机制定的一套内存模型，一套规范来屏蔽不同计算机底层区别

首先来看一看处理器的内存模型：

现在处理器的速度远远大于内存的存取速度。为了减缓处理器等待内存拿数据的时间，推出了缓存这一告诉缓存来作为处理器和内存之间的缓冲。



基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（CacheCoherence）。



在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存：

![image-20221226122142489](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20221226122142489.png)



**Java内存模型(JavaMemoryModel)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量，存储到内存和从内存中读取变量这样的底层细节。**



所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部

变量，因为局部变量是线程私有的，因此不存在竞争问题。

每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。

线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。

不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。



总结：线程操作必须在相互不可见的工作内存中完成数据的读写操作



![image-20221226122302112](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20221226122302112.png)

### 在JMM中的内存交互操作

关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、 如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：

- lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。 
- unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放 后的变量才可以被其他线程锁定。 
- read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存 中，以便随后的load动作使用
-  load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放 入工作内存的变量副本中。
-  use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引 擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 
- assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给 工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
-  store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主 内存中，以便随后的write的操作。 
- write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值 传送到主内存的变量中。

![image-20221226123140337](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20221226123140337.png)

Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

- 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操 作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。 但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。
-  不允许read和load、store和write操作之一单独出现 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须 同步到主内存中。 
- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回 主内存中。 
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化 （load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过 了assign和load操作。 
- 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条 线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解 锁。lock和unlock必须成对出现 
- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用 这个变量前需要重新执行load或assign操作初始化变量的值 
- 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许 去unlock一个被其他线程锁定的变量。
-  对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和 write操作）。



### 什么是可见性的问题

可见性问题，一个线程修改变量后在工作内存中还没有及时刷回主存，此时另一个线程读取到主存中以前的值，导致一个线程的操作对另一个线程操作的不可见。

可见性问题有以下三种情况

1. 单线程程序

单线程程序不会出现内存可见性问题。编译器、runtime和处理器会 共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。

2. 正确同步的多线程程序

正确同步的多线程程序的执行将具有顺序一致性（程序的 执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点， JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。

3. 未同步/为正确同步的多线程程序

JMM为它们提供了最小安全性保障：线程执行 时读取到的值，要么是之前某个线程写入的值，要么是默认值未同步程序在JMM中的执 行时，整体上是无序的，其执行结果无法预知。 JMM不保证未同步程序的执行结果与 该程序在顺序一致性模型中的执行结果一致。



### volatile如何保证可见性？





### 什么是有序性问题



### volatile如何保证有序性？













