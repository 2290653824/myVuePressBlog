---
title: git三剑客
date: 2023-04-08 00:09:56
permalink: /pages/7c5934/
categories:
  - 其他
  - 开发工具
tags:
  - 
author: 
  name: xugaoyi
  link: https://github.com/xugaoyi
---

git add -u 仅仅添加已经被git追踪且跟新的

文件到咱存区，不会添加没有被跟踪的文件

git reset --hard

文件名字修改规范操作
之前的流程：
1. 将本地目录 mv fileName1 fileName2
2. 在暂存区 git rm fileName1
3. 将新文件加到暂存区 git add fileName2

git mv fileName1 fileName2 
可以不用进行add等

版本日志
git log
git log --oneline  以一行的形式显示日志
git log -n4    查看最新的n条日制
git log --graph  以地图的形式查看
git log --all   查看全部日志

git cat-file -t hash   查看hash 的类型
git cat-file -p hash  查看hash的具体信息

.git中四个重要的目录：
config 本地git配置信息
refs git中不同分之的信息
HEAD 当前使用的分支
objects 存放了tree等信息

git中的三个重要对象commit 、 tree、 blob

文件管理

![image-20230408114209684](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408114209684.png)

在Git中，commit、tree和blob是三个核心的对象类型，它们有着紧密的关系。

首先，blob（二进制大对象）是指文件的内容，它可以是任何类型的文件，包括源代码、图像、音频或视频等。每个blob在Git仓库中都有一个唯一的SHA-1哈希值来标识它。

其次，tree（树对象）是一种特殊的对象，它描述了一个目录的结构，包含一个或多个blob对象和其他tree对象，以及它们之间的关系。与blob一样，每个tree也有一个唯一的SHA-1哈希值。

最后，commit（提交对象）指向一个tree对象，并包含一些元数据，例如提交者、时间戳、提交消息等。当创建一个新的提交时，Git会创建一个新的commit对象并将其指向当前的tree对象。每个commit也有一个唯一的SHA-1哈希值。

因此，这三种对象类型的关系如下：一个commit对象指向一个tree对象，该tree对象描述了当前版本的目录结构，而该目录结构由一些blob对象组成，它们表示实际的文件内容。



一次commit对应着一个文件目录版本。一次commit会对应多个tree。一个tree相当于一个目录，tree下面也会对应多个tree或多个blob。一个blob相当于一个文件，在git中认为只要是文件内容相同，则认为是同一个blob



例如查看一个commit的详细信息：

git cat-file -p 4a4a8dea2a36bc3f476

![image-20230408120536680](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408120536680.png)

从里的tree我们都明白了，其实就是指向了一个文件。

但是这里的parent又是什么东西呢？

在 Git 中，每个提交记录都包含一个指向其父提交（或上一个提交）的指针。这些父提交可以是单个提交，也可以是多个提交，形成分支或合并历史记录。

在提交对象中，parent字段是一个指向一个或多个父提交的哈希值的列表。当创建一个新的提交时，Git 将会把当前的分支指向新的提交，同时将新的提交的 parent 字段设置为现有提交的哈希值。这样就形成了一系列有向无环图（DAG），用于表示代码库的历史版本。

**tree字段则指向该提交的根目录的哈希值**，表示这个提交所包含的文件和目录结构。通过跟踪 tree 和 parent 哈希值，Git 可以追溯整个代码库的历史记录，并允许用户查看先前的版本，比较更改和合并不同的历史记录。



问题：新建一个git仓库，有且仅有1个commit，仅仅包含/doc/readme，请问有多少个tree，多少个blob

![image-20230408141742391](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408141742391.png)



三大对象再理解

![image-20230412104615319](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412104615319.png)

这些对象都存在.git目录中的objects中

当我们进行clone或者push时，

![image-20230412105000394](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412105000394.png)



另外，如果更改一个文件的内容，只改变一点也会创建一个新的object，因为hash变了



需要细细研究，有点东西

https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247541766&idx=1&sn=8091a5f18aa7ede19557e2142637cf9a&chksm=e9c2c3f1deb54ae713eb48eb3e65e4a498df0ca0aca542cc4a971f261a0efe4aa79fff9e3bf9&mpshare=1&scene=23&srcid=0411xXR0BBftW5H0X098wgcm&sharer_sharetime=1681227533623&sharer_shareid=4d2ece652c18043ba9427f6fbfc02bc2#rd





什么是git中的分离头指针：

![image-20230408154444722](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408154444722.png)

HEAD detached at hash

Git的分离头指针（Detached HEAD）是指当前工作树（Working Tree）处于HEAD指针指向的提交（Commit）之外的一种状态。在分离头指针状态下，Git不再跟踪分支（Branch）而是直接跟踪提交。

使用`git checkout <commit>`命令切换到一个特定的提交时，就会进入分离头指针状态。这种情况通常发生在以下几种情况：

1. 执行`git checkout <tag>`或`git checkout <commit hash>`等命令，但未创建新的分支来跟踪这个提交；
2. 在某个分支上进行修改，但在提交这些修改前执行了`git checkout <commit>`命令。

如果在分离头指针状态下进行修改并提交，那么这些提交将会成为孤立的提交（Orphan Commits），也就是没有任何分支指向的提交。



怎么产生？

git checkout commitHash

这时就产生了分离头指针，改指针并没有与任何的分支进行关联，当然我们可以在这里进行提交，但是因为没有任何分支进行关联，当我们突然切换到另一个分支过后，分离头指针上提交的commit就会丢失

那么分离头指针就完全没有用了吗？

分离头指针的优点是：

1. 可以方便地查看、修改、测试历史提交，无需创建新的分支或拉取代码；
2. 可以快速切换到不同的提交和版本，方便进行版本回退；
3. 可以在不影响当前分支的情况下修改和提交代码。

分离头指针的缺点是：

1. 在分离头指针状态下进行修改并提交，这些提交将成为孤立的提交，没有任何分支指向它们，可能会导致难以维护的仓库历史；
2. 分离头指针状态下，无法使用`git pull`等命令自动获取最新的远程更新；
3. 当需要继续开发时，需要创建新的分支来跟踪当前的工作，否则会丢失之前的提交记录。

因此，在实际应用中，建议尽量避免使用分离头指针状态，只有在特殊情况下才使用。



HEAD与Branch

正常情况下HEAD中保存的数据是一个地址的引用。

从目录的ref来看，其实真实指向的是一个commit，所以最总一个head不是指向多个commit，而是指向一个具体的commit。而这个commit有父亲节点可以访问，就间接的包含了多个commit

既然HEAD和branch本质上都指向了commit，其实我们的所有操作基本上都是基于commit进行操作，比如对比两侧commit的差异：

git diff commit1 commit2

git diff HEAD HEAD^

Git diff HEAD HEAD^^

git diff HEAD HEAD~2



怎么删除不需要的分支

检测删除（可能检测是否需要合并）git branch -d 分支名

强制删除 git branch -D 分支名



修改已提交的commit的message

git commit -amend 对最近一次提交作出变更

![image-20230408161121477](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408161121477.png)



对旧的commit进行变更

git rebase -i commithash的父亲

rebase是基于的意思，我们要修改commit1，那么我们要在commit1的父节点来进行修改commit2

![image-20230408162942375](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408162942375.png)

需要进行实战commit message进行修改

首先最基本的就是应该知道git rebase到底有什么用

①目前看看项目中的git日志

![image-20230409012918100](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409012918100.png)

②我们现在要把00eebc1 的commit信息改为second

git rebase -i be58967 (注意，这里我们需要rebase想要更改的commit的父commit)

![image-20230409013450069](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409013450069.png)

从图上看出，真实有效的为第一行，其他的都是help注释，这里我们将pick改为reword来更改message

保存退出后，会自动跳转到下面的界面，我们将对应的数据更改为second就可以了

![image-20230409013533013](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409013533013.png)



可以看见更改成功了

![image-20230409013612048](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409013612048.png)

注意，以上的变更一般在自己开发的分支上进行变更，在合作开发时，一般不要随意变更别人message



怎么把几个连续的commit变为一个commit

①选择需要合并commit的父commit作为rebase。

![image-20230409014942471](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409014942471.png)



如图所示，我想要合并2,3,4 那么我应该将first作为rebase

Git rebase -i be58967

②将要进行合并的分支选做squash命令

![image-20230409015722356](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409015722356.png)

③添加合并后的commit message

![image-20230409015840569](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409015840569.png)

合并成功·

![image-20230409015951181](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409015951181.png)

从上面可以看出来，似乎rebase操作都会涉及到**分离头指针**

看到上面的，合并后的commit相当于生成了一个新的commitHash，而最新的节点commit因为其父节点变化了，所以自己也产生了一个新的commithash,所以才会出现updated refs/heads/main，就是因为分支main指向的节点已经变化了。



怎么把几个间隔的commit变成一个comomit

![image-20230409023057138](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409023057138.png)

如图所示，我想将first合并到fifth分支，该怎么做了。我们之前说了rebase要有一个根基，但是现在first父节点我们是没有的该怎么办？

- 复制first的hash，然后在rebase -i中进行添加

![image-20230409023422335](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409023422335.png)

如图所示，我们手动添加了第一行commit。



现在我们要将first合并到fifth应该怎么做了？

![image-20230409023614781](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409023614781.png)

若果有冲突解决冲突，然后填写新commit的message

![image-20230409023837990](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409023837990.png)



保存退出即可:

![image-20230409023908863](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409023908863.png)



怎么对比暂存区与已经提交的版本之间的差异

git diff --cached

怎么对比工作区与暂存区之间的差异

git diff

只针对某一个文件

git diff -- fileName1 fileName2



撤销暂存区

git reset Head -- filename1 filename2

Git reset HEAD 撤销全部



撤销工作区

git checkout -- filename1 filename2



删除最近的几次commit

git reset --hard hash





看几次commit之间的差异

git diff commt1 commit2 -- file



删除文件姿势

git rm file

也会自动将工作区的进行文件删除



git stash pop /apply 区别



指定不需要纳入git的文件

.gitignore







