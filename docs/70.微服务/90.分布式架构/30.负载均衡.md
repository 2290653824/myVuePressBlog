 ## 一. 什么是负载均衡？ 

>  	从单机网站到分布式网站，很重要的区别是业务拆分和分布式部署，将应用拆分后，部署到不同的机器上，实现大规模分布式系统。分布式和业务拆分解决了，从集中到分布的问题，但是每个部署的独立业务还存在单点的问题和访问统一入口问题，为解决单点故障，我们可以采取冗余的方式。将相同的应用部署到多台机器上。解决访问统一入口问题，我们可以在集群前面增加负载均衡设备，实现流量分发。



​	负载均衡 指的是将用户请求分摊到不同的服务器上处理，以提高系统整体的并发处理能力以及可靠性。负载均衡服务可以有由专门的软件或者硬件来完成，一般情况下，硬件的性能更好，软件的价格更便宜（后文会详细介绍到）。

​	从图中可以看出，系统的商品服务部署了多份在不同的服务器上，为了实现访问商品服务请求的分流，我们用到了负载均衡。



![image-20230619112747236](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230619112747236.png)

负载均衡是一种比较常用且实施起来较为简单的提高系统并发能力和可靠性的手段，不论是单体架构的系统还是微服务架构的系统几乎都会用到。



###  负载均衡通常分为哪两种？ 



负载均衡可以简单分为 **服务端负载均衡** 和 **客户端负载均衡** 这两种。



服务端负载均衡涉及到的知识点更多，工作中遇到的也比较多，因为，我会花更多时间来介绍。



### 负载均衡的作用

1.解决并发压力，提高应用处理性能（增加吞吐量，加强网络处理能力）；

2.提供故障转移，实现高可用；

3.通过添加或减少服务器数量，提供网站伸缩性（扩展性）；

4.安全防护；（负载均衡设备上做一些过滤，黑白名单等处理）



 ## 二. 服务端负载均衡 



服务端负载均衡 主要应用在 系统外部请求 和 网关层 之间，可以使用 软件 或者 硬件 实现。



下图是我画的一个简单的基于 Nginx 的服务端负载均衡示意图：



![image-20230619113205019](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230619113205019.png)





**硬件负载均衡** 通过专门的硬件设备（比如 F5、A10、Array ）实现负载均衡功能。



硬件负载均衡的优势是性能很强且稳定，缺点就是实在是太贵了。像基础款的 F5 最低也要 20 多万，绝大部分公司是根本负担不起的，业务量不大的话，真没必要非要去弄个硬件来做负载均衡，用软件负载均衡就足够了！



在我们日常开发中，一般很难接触到硬件负载均衡，接触的比较多的还是 软件负载均衡 。软件负载均衡通过软件（比如 LVS、Nginx、HAproxy ）实现负载均衡功能，性能虽然差一些，但价格便宜啊！像基础款的 Linux 服务器也就几千，性能好一点的 2~3 万的就很不错了。



根据 OSI 模型，服务端负载均衡还可以分为：



●二层负载均衡

●三层负载均衡

●四层负载均衡

●七层负载均衡



最常见的是四层和七层负载均衡，因此，本文也是重点介绍这两种负载均衡。



![image-20230619141457276](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230619141457276.png)





- 四层负载均衡 工作在 OSI 模型第四层，也就是传输层，这一层的主要协议是 TCP/UDP，负载均衡器在这一层能够看到数据包里的源端口地址以及目的端口地址，会基于这些信息通过一定的负载均衡算法将数据包转发到后端真实服务器。

- 七层负载均衡 工作在 OSI 模型第七层，也就是应用层，这一层的主要协议是 HTTP 。这一层的负载均衡比四层负载均衡路由网络请求的方式更加复杂，它会读取报文的数据部分（比如说我们的 HTTP 部分的报文），然后根据读取到的数据内容（如 URL、Cookie）做出负载均衡决策。



七层负载均衡比四层负载均衡会消耗更多的性能，不过，也相对更加灵活，能够更加智能地路由网络请求，比如说你可以根据请求的内容进行优化如缓存、压缩、加密。



简单来说，**四层负载均衡性能更强，七层负载均衡功能更强！**









不过，LVS 这个绝大部分公司真用不上，像阿里、百度、腾讯、eBay 等大厂才会使用到，用的最多的还是 Nginx。



## 三. 客户端负载均衡 

客户端负载均衡 主要应用于系统内部的不同的服务之间，可以使用现成的负载均衡组件来实现。



在客户端负载均衡中，客户端会自己维护一份服务器的地址列表，发送请求之前，客户端会根据对应的负载均衡算法来选择具体某一台服务器处理请求。



客户端负载均衡器和服务运行在同一个进程或者说 Java 程序里，不存在额外的网络开销。不过，客户端负载均衡的实现会受到编程语言的限制，比如说 Spring Cloud Load Balancer 就只能用于 Java 语言。



Java 领域主流的微服务框架 Dubbo、Spring Cloud 等都内置了开箱即用的客户端负载均衡实现。Dubbo 属于是默认自带了负载均衡功能，Spring Cloud 是通过组件的形式实现的负载均衡，属于可选项，比较常用的是 Spring Cloud Load Balancer（官方，推荐） 和 Ribbon（Netflix，已被启用）。



下图是我画的一个简单的基于 Spring Cloud Load Balancer（Ribbon 也类似） 的客户端负载均衡示意图：

![image-20230619141742466](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230619141742466.png)









## 四.七层负载均衡可以怎么做？ 



简单介绍两种项目中常用的七层负载均衡解决方案：DNS 解析和反向代理。



除了我介绍的这两种解决方案之外，HTTP 重定向等手段也可以用来实现负载均衡，不过，相对来说，还是 DNS 解析和反向代理用的更多一些，也更推荐一些。



#### DNS 解析 



DNS 解析是比较早期的七层负载均衡实现方式，非常简单。



DNS 解析实现负载均衡的原理是这样的：在 DNS 服务器中为同一个主机记录配置多个 IP 地址，这些 IP 地址对应不同的服务器。当用户请求域名的时候，DNS 服务器采用轮询算法返回 IP 地址，这样就实现了轮询版负载均衡。大型网站总是部分使用DNS解析，作为第一级负载均衡。如下图：



![image-20230619142002767](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230619142002767.png)





现在的 DNS 解析几乎都支持 IP 地址的权重配置，这样的话，在服务器性能不等的集群中请求分配会更加合理化。像我自己目前正在用的阿里云 DNS 就支持权重配置。



![image-20230619142011546](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230619142011546.png)

**实践建议**

将DNS作为第一级负载均衡，A记录对应着内部负载均衡的IP地址，通过内部负载均衡将请求分发到真实的Web服务器上。一般用于互联网公司，复杂的业务系统不合适使用。如下图：

![image-20230619144448192](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230619144448192.png)

#### 反向代理 



客户端将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器，获取数据后再返回给客户端。对外暴露的是反向代理服务器地址，隐藏了真实服务器 IP 地址。反向代理“代理”的是目标服务器，这一个过程对于客户端而言是透明的。



Nginx 就是最常用的反向代理服务器，它可以将接收到的客户端请求以一定的规则（负载均衡策略）均匀地分配到这个服务器集群中所有的服务器上。



反向代理负载均衡同样属于七层负载均衡。

![image-20230619142028989](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230619142028989.png)



## 五.其他层次的负载均衡怎么做？

### IP负载均衡

在网络层通过修改请求目标地址进行负载均衡。

用户请求数据包，到达负载均衡服务器后，负载均衡服务器在操作系统内核进程获取网络数据包，根据负载均衡算法得到一台真实服务器地址，然后将请求目的地址修改为，获得的真实ip地址，不需要经过用户进程处理。

真实服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器，再将数据包源地址修改为自身的ip地址，发送给用户浏览器。如下图：

![image-20230619144802708](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230619144802708.png)

IP负载均衡，真实物理服务器返回给负载均衡服务器，存在两种方式：（1）负载均衡服务器在修改目的ip地址的同时修改源地址。将数据包源地址设为自身盘，即源地址转换（snat）。（2）将负载均衡服务器同时作为真实物理服务器集群的网关服务器。

- 优点
  - 在内核进程完成数据分发，比在应用层分发性能更好；
- 缺点
  - 所有请求响应都需要经过负载均衡服务器，集群最大吞吐量受限于负载均衡服务器网卡带宽；

### 链路层负载均衡

在通信协议的数据链路层修改mac地址，进行负载均衡。

数据分发时，不修改ip地址，指修改目标mac地址，配置真实物理服务器集群所有机器虚拟ip和负载均衡服务器ip地址一致，达到不修改数据包的源地址和目标地址，进行数据分发的目的。

实际处理服务器ip和数据请求目的ip一致，不需要经过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。也称为直接路由模式（DR模式）。如下图：

![image-20230619144809963](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230619144809963.png)

优点：性能好；

缺点：配置复杂；

实践建议：DR模式是目前使用最广泛的一种负载均衡方式。

###  合型负载均衡

由于多个服务器群内硬件设备、各自的规模、提供的服务等的差异，可以考虑给每个服务器群采用最合适的负载均衡方式，然后又在这多个服务器群间再一次负载均衡或群集起来以一个整体向外界提供服务（即把这多个服务器群当做一个新的服务器群），从而达到最佳的性能。将这种方式称之为混合型负载均衡。

此种方式有时也用于单台均衡设备的性能不能满足大量连接请求的情况下。是目前大型互联网公司，普遍使用的方式。

方式一，如下图：

![image-20230619144817850](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230619144817850.png)

以上模式适合有动静分离的场景，反向代理服务器（集群）可以起到缓存和动态请求分发的作用，当时静态资源缓存在代理服务器时，则直接返回到浏览器。如果动态页面则请求后面的应用负载均衡（应用集群）。

方式二，如下图：

![image-20230619144828091](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230619144828091.png)

以上模式，适合动态请求场景。

因混合模式，可以根据具体场景，灵活搭配各种方式，以上两种方式仅供参考。



## 六.客户端负载均衡通常是怎么做的？ 



我们上面也说了，客户端负载均衡可以使用现成的负载均衡组件来实现。



Netflix Ribbon 和 Spring Cloud Load Balancer 就是目前 Java 生态最流行的两个负载均衡组件。



Ribbon 是老牌负载均衡组件，由 Netflix 开发，功能比较全面，支持的负载均衡策略也比较多。 Spring Cloud Load Balancer 是  Spring 官方为了取代 Ribbon 而推出的，功能相对更简单一些，支持的负载均衡也少一些。



Ribbon 支持的 7 种负载均衡策略：



●RandomRule ：随机策略。

●RoundRobinRule（默认） ：轮询策略

●WeightedResponseTimeRule ：权重（根据响应时间决定权重）策略

●BestAvailableRule ：最小连接数策略

●RetryRule：重试策略（按照轮询策略来获取服务，如果获取的服务实例为 null 或已经失效，则在指定的时间之内不断地进行重试来获取服务，如果超过指定时间依然没获取到服务实例则返回 null）

●AvailabilityFilteringRule ：可用敏感性策略（先过滤掉非健康的服务实例，然后再选择连接数较小的服务实例）

●ZoneAvoidanceRule ：区域敏感性策略（根据服务所在区域的性能和服务的可用性来选择服务实例）



Spring Cloud Load Balancer  支持的 2 种负载均衡策略：



●RandomLoadBalancer ：随机策略

●RoundRobinLoadBalancer（默认） ：轮询策略







```java
public class CustomLoadBalancerConfiguration {

    @Bean
    ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory) {

        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);

        return new RandomLoadBalancer(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name);
    }

}

```







不过，Spring Cloud Load Balancer  支持的负载均衡策略其实不止这两种，ServiceInstanceListSupplier 的实现类同样可以让其支持类似于 Ribbon 的负载均衡策略。这个应该是后续慢慢完善引入的，不看官方文档还真发现不了，所以说阅读官方文档真的很重要！



这里举两个官方的例子：



●ZonePreferenceServiceInstanceListSupplier ：实现基于区域的负载平衡

●HintBasedServiceInstanceListSupplier ：实现基于 hint 提示的负载均衡



```java
public class CustomLoadBalancerConfiguration {

    // 使用基于区域的负载平衡方法

    @Bean
    public ServiceInstanceListSupplier discoveryClientServiceInstanceListSupplier(ConfigurableApplicationContext context) {
        return ServiceInstanceListSupplier.builder().withDiscoveryClient().withZonePreference().withCaching().build(context);
    }

}
```



关于Spring Cloud Load Balancer更详细更新的介绍，推荐大家看看官方文档：https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-loadbalancer ，一切以官方文档为主。



轮询策略基本可以满足绝大部分项目的需求，我们的实际项目中如果没有特殊需求的话，通常使用的就是默认的轮询策略。并且，Ribbon 和 Spring Cloud Load Balancer  都支持自定义负载均衡策略。



个人建议如非必需 Ribbon 某个特有的功能或者负载均衡策略的话，就优先选择 Spring 官方提供的 Spring Cloud Load Balancer。



最后再说说为什么我不太推荐使用 Ribbon 。



Spring Cloud 2020.0.0 版本移除了 Netflix 除 Eureka 外的所有组件。Spring Cloud Hoxton.M2 是第一个支持 Spring Cloud Load Balancer 来替代 Netfix Ribbon 的版本。



我们早期学习微服务，肯定接触过 Netflix 公司开源的 Feign、Ribbon、Zuul、Hystrix、Eureka 等知名的微服务系统构建所必须的组件，直到现在依然有非常非常多的公司在使用这些组件。不夸张地说，Netflix 公司引领了 Java 技术栈下的微服务发展。



![image-20230619142341824](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230619142341824.png)





那为什么 Spring Cloud 这么急着移除 Netflix 的组件呢？ 主要是因为在 2018 年的时候，Netflix 宣布其开源的核心组件 Hystrix、Ribbon、Zuul、Eureka 等进入维护状态，不再进行新特性开发，只修 BUG。于是，Spring 官方不得不考虑移除 Netflix 的组件。



Spring Cloud Alibaba 是一个不错的选择，尤其是对于国内的公司和个人开发者来说。



## 七.负载均衡常见的算法有哪些？ 

#### 随机法 

随机法 是最简单粗暴的负载均衡算法。



如果没有配置权重的话，所有的服务器被访问到的概率都是相同的。如果配置权重的话，权重越高的服务器被访问的概率就越大。



未加权重的随机算法适合于服务器性能相近的集群，其中每个服务器承载相同的负载。



不过，随机算法有一个比较明显的缺陷：部分机器在一段时间之内无法被随机到，毕竟是概率算法，就算是大家权重一样， 也可能会出现这种情况。



#### 加权随机法

与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。



#### 轮询法 



轮询法是挨个轮询服务器处理，也可以设置权重。



如果没有配置权重的话，每个请求按时间顺序逐一分配到不同的服务器处理。如果配置权重的话，权重越高的服务器被访问的次数就越多。



未加权重的轮询算法适合于服务器性能相近的集群，其中每个服务器承载相同的负载。

#### 加权轮询法

不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。

#### 源地址哈希法

源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。



缺点：如果后端服务器面临着扩容，那么原来对应的映射关系就会发生改变，如果客户端在对应的服务器有状态的话，就需要全部进行哈希重新分配，非常麻烦。解决方式：一致性hash，少量数据重新哈希分配。



#### 一致性 Hash 法 

一致性哈希算法（Consistent Hashing）是一种用于分布式系统中数据分片和负载均衡的算法。它的原理是将数据和节点映射到一个固定大小的哈希环上，通过对哈希环进行散列，实现数据和节点的均匀分布。

以下是一致性哈希算法的原理步骤：

1. 创建一个固定大小的哈希环（通常使用一个 2^32 或 2^64 大小的环）。
2. 将节点（例如服务器）通过哈希函数映射到哈希环上的某个位置。
3. 将数据通过哈希函数映射到哈希环上的某个位置，得到一个哈希值。
4. 从数据的哈希值开始，顺时针找到离它最近的节点位置，并将数据存储在该节点上。

一致性哈希算法的优点是在节点的增加或删除时，能够最小化数据迁移的量。当添加或删除一个节点时，只会影响到环上该节点到下一个节点之间的数据迁移，而不会对整个环产生剧烈的数据迁移。

此外，一致性哈希算法对于负载均衡也具有良好的性能。当需要查找一个数据所在的节点时，只需经过少量的计算即可找到对应的节点，而无需遍历整个节点列表。

一致性哈希算法常被应用于缓存系统、分布式存储系统和分布式数据库等场景，以提高系统的可扩展性、负载均衡性和容错性。

详细可看：[一致性hash与hash槽算法](https://2290653824.github.io/pages/0cac46/#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95)



#### 最小连接法 



当有新的请求出现时，遍历服务器节点列表并选取其中活动连接数最小的一台服务器来响应当前请求。活动连接数可以理解为当前正在处理的请求数。



最小连接法可以尽可能最大地使请求分配更加合理化，提高服务器的利用率。不过，这种方法实现起来也最复杂，需要监控每一台服务器处理的请求连接数。

