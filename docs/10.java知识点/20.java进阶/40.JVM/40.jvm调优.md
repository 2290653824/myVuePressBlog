---
title: jvm调优
date: 2023-06-09 17:07:38
permalink: /pages/f070cc/
categories:
  - java
  - java进阶
  - JVM
tags:
  - 
author: 
  name: xugaoyi
  link: https://github.com/xugaoyi
---


## JVM常见工具介绍

### [#](https://www.sharkchili.com/pages/3361b8/#jinfo-查看配置信息)jinfo(查看配置信息)

查看`Java`应用程序配置参数或者`JVM`系统属性，相关命令详情我们可以使用`-help`或者`man`命令查看，如下所示:

```go
[root@xxxxxtmp]# jinfo -help
Usage:
    jinfo [option] <pid>
        (to connect to running process)
    jinfo [option] <executable <core>
        (to connect to a core file)
    jinfo [option] [server_id@]<remote server IP or hostname>
        (to connect to remote debug server)

where <option> is one of:
    -flag <name>         to print the value of the named VM flag
    -flag [+|-]<name>    to enable or disable the named VM flag
    -flag <name>=<value> to set the named VM flag to the given value
    -flags               to print VM flags
    -sysprops            to print Java system properties
    <no option>          to print both of the above
    -h | -help           to print this help message
```

为了演示，笔者在服务器上开启了一个Java应用，我们可以使用`jps`命令查看其进程`id`,可以看到笔者服务器中有一个`pid`为`19946`的Java进程。

```text
[root@iZ8vb7bhe4b8nhhhpavhwpZ tmp]# jps
20104 Jps
19946 jar
```

查看当前应用所有的配置参数以及系统配置属性命令为`jinfo pid`如下所示:

```text
[root@xxxxx tmp]# jinfo 19946
Attaching to process ID 19946, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.202-b08
Java System Properties:

java.runtime.name = Java(TM) SE Runtime Environment
java.vm.version = 25.202-b08
sun.boot.library.path = /root/jdk8/jre/lib/amd64
java.protocol.handler.pkgs = org.springframework.boot.loader
java.vendor.url = http://java.oracle.com/
java.vm.vendor = Oracle Corporation
path.separator = :
file.encoding.pkg = sun.io
java.vm.name = Java HotSpot(TM) 64-Bit Server VM
sun.os.patch.level = unknown
sun.java.launcher = SUN_STANDARD
user.country = US
user.dir = /tmp


......
```

如果我们希望查看当前Java应用是否有配置某些信息，可以使用命令`jinfo -flag 配置选项 pid`，例如我们想查看当前应用是否有开启`gc选项`，可以使用下面这段命令

可以看到输出结果为`-XX:-PrintGC`，因为`PrintGC`前面是减号，这说明该选项并没有开启。

```go
[root@xxx tmp]# jinfo -flag PrintGC 19946
-XX:-PrintGC
```

如果我们希望将这个选项开启，我们只需在参数前面加个+号即可，例如我们希望开启`gc选项`，我们只需键入如下命令

```go
[root@xxxxxtmp]# jinfo -flag +PrintGC 19946
```

再次查看可以发现，选项生效了

```go
[root@xxxx tmp]# jinfo -flag PrintGC 19946
-XX:+PrintGC
```

有些参数是键值对的形式，例如我们想配置dump日志的路径，我们也可以使用jinfo进行配置，命令格式为`jinfo -flag 参数=值 Java进程id`

```text
jinfo -flag HeapDumpPath=/tmp/dump.log 19946
```

打印JVM选项信息

```text
jinfo -flags 4854
Attaching to process ID 4854, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.202-b08
Non-default VM flags: -XX:CICompilerCount=2 -XX:HeapDumpPath=null -XX:InitialHeapSize=33554432 -XX:MaxHeapSize=511705088 -XX:MaxNewSize=170524672 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=11141120 -XX:OldSize=22413312 -XX:+PrintGC -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps
Command line:
```

查看应用属性，命令格式`jinfo -sysprops Java进程id`

```text
jinfo -sysprops 2341
```

### [#](https://www.sharkchili.com/pages/3361b8/#jmap-查看堆区信息、对象信息等)jmap(查看堆区信息、对象信息等)

`jmap`作用:

1. 查看使用的GC算法，堆的配置信息以及各个内存区域的内存使用情况
2. 显示堆对象的统计信息，包括每一个`Java`类、对象数量、内存大小、类名称等
3. 打印等会回收的对象的信息
4. 生成`dump`文件，配合`jhat`使用

查看堆内存使用情况 `jmap -heap Java进程id`

```text
[root@iZ8vb7bhe4b8nhhhpavhwpZ tmp]# jmap -heap 25534
Attaching to process ID 25534, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.202-b08

using thread-local object allocation.
Mark Sweep Compact GC

Heap Configuration:
   MinHeapFreeRatio         = 40
   MaxHeapFreeRatio         = 70
   MaxHeapSize              = 511705088 (488.0MB)
   NewSize                  = 11141120 (10.625MB)
   MaxNewSize               = 170524672 (162.625MB)
   OldSize                  = 22413312 (21.375MB)
   NewRatio                 = 2
   SurvivorRatio            = 8
   MetaspaceSize            = 21807104 (20.796875MB)
   CompressedClassSpaceSize = 1073741824 (1024.0MB)
   MaxMetaspaceSize         = 17592186044415 MB
   G1HeapRegionSize         = 0 (0.0MB)
```

查看存活的`Java`对象，命令格式: `jmap -histo:live Java进程id`

```text
[root@xxxtmp]# jmap -histo:live 25534

 num     #instances         #bytes  class name
----------------------------------------------
   1:         48676        7974952  [C
   2:          7762        1873312  [I
   3:         47785        1146840  java.lang.String
   4:         12737        1120856  java.lang.reflect.Method
   5:          8773         968912  java.lang.Class
   6:         25572         818304  java.util.concurrent.ConcurrentHashMap$Node
   7:         14108         564320  java.util.LinkedHashMap$Entry
   8:          2712         509536  [B
   9:          9308         494936  [Ljava.lang.Object;
  10:          6345         493128  [Ljava.util.HashMap$Node;
  11:          7001         392056  java.util.LinkedHashMap
  12:         11255         360160  java.util.HashMap$Node
  13:         15946         354528  [Ljava.lang.Class;
  14:         18176         290816  java.lang.Object
  15:          3447         248184  java.lang.reflect.Field
  16:           124         192320  [Ljava.util.concurrent.ConcurrentHashMap$Node;
```

打印正在被回收的类,命令格式:`jmap -finalizerinfo Java进程id`

```text
[root@xxxtmp]# jmap -finalizerinfo 25534
Attaching to process ID 25534, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.202-b08
Number of objects pending for finalization: 0
```

将存活的对象的信息存到二进制文件中

```text
 jmap -dump:live,format=b,file=/tmp/heap.bin 25534
Dumping heap to /tmp/heap.bin ...
Heap dump file created
```

此时就可以使用`jhat`打开该文件,如下所示`jhat 文件名`,这时候我们就可以通过`7000`端口查看详情了。

```text
[root@xxxtmp]# jhat heap.bin
Reading from heap.bin...
Dump file created Wed Nov 02 20:21:18 CST 2022
Snapshot read, resolving...
Resolving 346825 objects...
Chasing references, expect 69 dots.....................................................................
Eliminating duplicate references.....................................................................
Snapshot resolved.
Started HTTP server on port 7000
Server is ready.
```

### [#](https://www.sharkchili.com/pages/3361b8/#jstat-常用-监控运行时状态信息)jstat(常用，监控运行时状态信息)

jstat用于监控虚拟机各种运行状态信息，显示虚拟机进程中装在、内存、垃圾收集、JIT编译等运行数据。

查看类加载信息，命令格式`jstat -class Java进程id`

```text
[root@iZ8vb7bhe4b8nhhhpavhwpZ tmp]# jstat -class 2341
Loaded  Bytes  Unloaded  Bytes     Time
  8221 14604.3        1     0.9      12.74
[root@iZ8vb7bhe4b8nhhhpavhwpZ tmp]#
```

查看编译统计信息`jstat -compiler Java进程id`

```text
[root@xxxtmp]# jstat -compiler 2341
Compiled Failed Invalid   Time   FailedType FailedMethod
    4177      0       0    17.68          0
[root@iZ8vb7bhe4b8nhhhpavhwpZ tmp]#
```

查看`gc`统计信息

```text
[root@iZ8vb7bhe4b8nhhhpavhwpZ tmp]# jstat -gc 2341
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
1408.0 1408.0  0.0   1020.3 11840.0   7493.1   29268.0    22168.5   42840.0 40613.5 5760.0 5311.9     65    0.401   2      0.213    0.613
[root@iZ8vb7bhe4b8nhhhpavhwpZ tmp]#
```

每个表头的含义如下

```text
1. S0C :年轻代中第一个survivor（幸存区）的容量 (字节)
2. S1C :年轻代中第二个survivor（幸存区）的容量 (字节)
3. S0U:年轻代中第一个survivor（幸存区）目前已使用空间 (字节)
4. S1U:年轻代中第二个survivor（幸存区）目前已使用空间 (字节)
5. EC:年轻代中Eden（伊甸园）的容量 (字节)
6. EU:年轻代中Eden（伊甸园）目前已使用空间 (字节)
7. OC:Old代的容量 (字节)
8. OU:Old代目前已使用空间 (字节)
9. PC:Perm(持久代)的容量 (字节)
10. PU:Perm(持久代)目前已使用空间 (字节)
11. YGC:从应用程序启动到采样时年轻代中gc次数
12. YGCT:从应用程序启动到采样时年轻代中gc所用时间(s)
13. FGC:从应用程序启动到采样时old代(全gc)gc次数
14. FGCT:从应用程序启动到采样时old代(全gc)gc所用时间(s)
15. GCT:从应用程序启动到采样时gc用的总时间(s)
```

查看gc内存容量和元空间容量

```text
[root@xxxtmp]# jstat -gccapacity 2341
 NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC
 10880.0 166528.0  14656.0 1408.0 1408.0  11840.0    21888.0   333184.0    29268.0    29268.0      0.0 1087488.0  42840.0      0.0 1048576.0   5760.0     65     2
```

查看年轻代统计信息

```text
[root@xxxxtmp]# jstat -gcnew 2341
 S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT
1408.0 1408.0    0.0 1020.3  2  15  704.0  11840.0   7652.5     65    0.401
[root@iZ8vb7bhe4b8nhhhpavhwpZ tmp]#
```

参数详情

```text
1. S0C:年轻代中第一个survivor（幸存区）的容量 (字节)
2. S1C:年轻代中第二个survivor（幸存区）的容量 (字节)
3. S0U:年轻代中第一个survivor（幸存区）目前已使用空间 (字节)
4. S1U:年轻代中第二个survivor（幸存区）目前已使用空间 (字节)
5. TT:持有次数限制
6. MTT:最大持有次数限制
7. EC:年轻代中Eden（伊甸园）的容量 (字节)
8. EU:年轻代中Eden（伊甸园）目前已使用空间 (字节)
9. YGC:从应用程序启动到采样时年轻代中gc次数
10. YGCT:从应用程序启动到采样时年轻代中gc所用时间(s)
```

## [#](https://www.sharkchili.com/pages/3361b8/#了解jvm-gc日志)了解JVM GC日志

### [#](https://www.sharkchili.com/pages/3361b8/#获取日志的两种方式)获取日志的两种方式

获取GC日志方式大抵有以下两种:

1. 设定JVM参数,具体的命令参数为:

```text
-XX:+PrintGCDetails # 打印GC日志
-XX:+PrintGCTimeStamps # 打印每一次触发GC时发生的时间
```

1. 在服务器上监控:使用`jstat`查看,如下所示，命令格式为`jstat -gc pid 输出间隔时长 输出次数`

```go
[root@xxxxx tmp]# jstat -gc 21608 1000 5
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
1088.0 1088.0  0.0   666.5   8832.0   3102.0   21888.0    11286.8   32512.0 30346.5 4352.0 3842.7     31    0.161   1      0.035    0.195
1088.0 1088.0  0.0   666.5   8832.0   3102.0   21888.0    11286.8   32512.0 30346.5 4352.0 3842.7     31    0.161   1      0.035    0.195
1088.0 1088.0  0.0   666.5   8832.0   3102.0   21888.0    11286.8   32512.0 30346.5 4352.0 3842.7     31    0.161   1      0.035    0.195
1088.0 1088.0  0.0   666.5   8832.0   3102.0   21888.0    11286.8   32512.0 30346.5 4352.0 3842.7     31    0.161   1      0.035    0.195
1088.0 1088.0  0.0   666.5   8832.0   3102.0   21888.0    11286.8   32512.0 30346.5 4352.0 3842.7     31    0.161   1      0.035    0.195
```

### [#](https://www.sharkchili.com/pages/3361b8/#常见配置参数解析)常见配置参数解析

对应的JVM参数和含义笔者都注释解释了，读者可自行阅读

```text
-XX:NewSize=5M # 年轻代空间大小
-XX:MaxNewSize=5M # 年轻代最大空间大小
-XX:InitialHeapSize=10M # 初始化堆空间大小
-XX:MaxHeapSize=10M # 最大堆内存
-XX:SurvivorRatio=8 # eden占比，例如这里设置为8，那么eden和S0、S1区总体比例为8:1:1
-XX:PretenureSizeThreshold=10M # 大于这个值的参数直接在老年代分配。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存复制
-XX:+UseParNewGC # 年轻代使用的GC算法
-XX:+UseConcMarkSweepGC # 并行并发CMS垃圾回收器
-XX:+PrintGCDetails  # 打印GC日志详情
-XX:+PrintGCTimeStamps # 打印每次触发GC的时间
```

由上面的命令我可以知道堆区初始化内存和最大内存为`10M`，所以我们堆区的总空间为`10M`。 而年轻代的内存为`5M`，年轻代包含`Eden区`和`Survivor区`，由参数`XX:SurvivorRatio`可知`Eden`区占`8/10`，所以`Eden`区为`4M`，`Survivor区`总大小为`1M`，由于`Survivor`有两个所以每个`Survivor区`为`0.5M`。

![在这里插入图片描述](https://qiniuyun.sharkchili.com/img202304071111068.png)

### [#](https://www.sharkchili.com/pages/3361b8/#实践-基于idea调试应用程序了解堆jvm日志)(实践)基于IDEA调试应用程序了解堆JVM日志

为了演示如何查看`GC`日志，我们不妨写下这样一段代码，我们在计划将JVM年轻代设置为5M，首先创建3M的垃圾，然后创建2M的对象，触发`minor GC`。

编码如下所示:

```text
public class gcTest {
    public static void main(String[] args) {
        //制造3M的垃圾
        byte[] bytes = new byte[1024 * 1024];
        bytes = new byte[1024 * 1024];
        bytes = new byte[1024 * 1024];

        //创建2M的新对象触发GC
        byte[] byte2 = new byte[2 * 1024 * 1024];
    }
}
```

然后我在`IDEA`中的`JVM option`配日志下面这条命令，每一个参数的命令上面都给出了，不记得的读者可以翻到上文中查阅。

```text
-XX:NewSize=5M -XX:MaxNewSize=5M -XX:InitialHeapSize=10M -XX:MaxHeapSize=10M -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=10M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps
```

![在这里插入图片描述](https://qiniuyun.sharkchili.com/img202304071111331.png)

完成后运行代码，可以在控制台输出下面这样一段内容，我们不妨逐行解释一下详情

![在这里插入图片描述](https://qiniuyun.sharkchili.com/img202304071111185.png)

首先是第一行，意为`0.059s`触发`年轻代gc`，年轻代使用空间从`3655K`变为`512K`,而年轻代的总空间为`4608K(eden+有对象的s区)`。

后面`3655K->1671K(9728K)`则是堆区总空间大小`9728K`，使用空间由`3655K`变为`1671K`。

后续`Times`按顺序即用户、系统、时机耗时时间。

```go
0.059: [GC (Allocation Failure) 0.059: [ParNew: 3655K->512K(4608K), 0.0008750 secs] 3655K->1671K(9728K), 0.0009085 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
```

接下来这段则是年轻代堆区信息使用情况，可以看到eden大小为4096K，使用了78%。from和to`(即s区)`同理。

```go
Heap
 par new generation   total 4608K, used 3746K [0x00000000ff600000, 0x00000000ffb00000, 0x00000000ffb00000)
  eden space 4096K,  78% used [0x00000000ff600000, 0x00000000ff9289d0, 0x00000000ffa00000)
  from space 512K, 100% used [0x00000000ffa80000, 0x00000000ffb00000, 0x00000000ffb00000)
  to   space 512K,   0% used [0x00000000ffa00000, 0x00000000ffa00000, 0x00000000ffa80000)
```

这一段以为老年代使用情况

```go
 concurrent mark-sweep generation total 5120K, used 1159K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)
```

最后两段为元数据和class空间使用情况，不常用到，就不多做解释了。

```go
 Metaspace       used 3159K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 343K, capacity 388K, committed 512K, reserved 1048576K
```

## [#](https://www.sharkchili.com/pages/3361b8/#了解jvm几种gc的区别)了解JVM几种GC的区别

1. `Minor GC:`发生在年轻代的空间回收，包含`eden`和`survivor`，也叫做`Young GC`。
2. `Major GC:`在老年代堆区进行空间回收。
3. `Full GC:`清理所有堆区的内存空间的垃圾内存，包括年轻代和老年代。

## [#](https://www.sharkchili.com/pages/3361b8/#实践-修复频繁的-minor-gc-和-major-gc)(实践)修复频繁的 Minor GC 和 Major GC

### [#](https://www.sharkchili.com/pages/3361b8/#了解频繁minor-gc的危害和原因)了解频繁Minor GC的危害和原因

造成`Minor GC`的原因说白了就是年轻代空间太少，当我们的应用程序需要频繁的创建对象时，就会触发`Minor GC`。 频繁的`Minor GC`会导致服务响应时间变长，而原因也很好理解，由上的介绍我们知道频繁的`Minor GC`会导致大量的年轻代垃圾被回收，并且会将存活的对象拷贝的老年代，而拷贝这个行为是非常消耗系统性能的。

### [#](https://www.sharkchili.com/pages/3361b8/#复现问题)复现问题

我们的程序编写如下所示，在一个for循环里面，创建`3M`的垃圾后，再创建`2M`的数组触发`GC`

```text
public class gcTest {
    public static void main(String[] args) throws Exception {
        while (true) {
            //制造3M的垃圾
            byte[] bytes = new byte[1024 * 1024];
            bytes = new byte[1024 * 1024];
            bytes = new byte[1024 * 1024];

            //创建2M的新对象触发GC
            byte[] byte2 = new byte[2 * 1024 * 1024];

            Thread.sleep(1000);
        }


    }
}
```

为了演示年轻代的回收行为，我们需要在对这个应用程序的年轻代堆内存改为`5M`

```text
-XX:NewSize=5M -XX:MaxNewSize=5M -XX:InitialHeapSize=10M -XX:MaxHeapSize=10M -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=10M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps
```

输出结果如下，可以看到在1s多就频繁的`Minor GC`。

![在这里插入图片描述](https://qiniuyun.sharkchili.com/img202304071111509.png)

### [#](https://www.sharkchili.com/pages/3361b8/#修复并解决问题)修复并解决问题

我们不妨将年轻代和老年代、初始化堆区的空间都扩大，如下所示

```text
-XX:NewSize=10M -XX:MaxNewSize=10M -XX:InitialHeapSize=100M -XX:MaxHeapSize=100M -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=10M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps
```

输出结果，可以看到发生`GC`的时间间隔明显长了。

![在这里插入图片描述](https://qiniuyun.sharkchili.com/img202304071111220.png)

### [#](https://www.sharkchili.com/pages/3361b8/#将年轻代空间调大-是否会更加耗时)将年轻代空间调大，是否会更加耗时？

答案是不会的，我们将一次`GC`的时间拆分为`t1`和`t2`，`t1`是扫描年轻代空间是否有垃圾的时间，这个时间的几乎可以忽略不计。而t2则是将`eden`空间存活的对象复制到`survivor`区的时间，这个复制操作则是t1时间的10倍。 很明显的，JVM的性能瓶颈是t2`(拷贝存活对象到s区)`，所以增加年轻代空间避免没必要的拷贝是正确的做法。

![在这里插入图片描述](https://qiniuyun.sharkchili.com/img202304071111199.png)

## [#](https://www.sharkchili.com/pages/3361b8/#实践-频繁的full-gc)(实践)频繁的FULL GC

### [#](https://www.sharkchili.com/pages/3361b8/#简介)简介

`FULL GC`的原因即老年区空间满了，需要完完整整走一遍垃圾回收了。注意`FULL GC`可能会导致整个应用程序阻塞。

### [#](https://www.sharkchili.com/pages/3361b8/#重点-了解cms-gc日志)(重点)了解CMS GC日志

在进行FULL GC问题实践之前，我们必须了解一下CMS GC的七大阶段:

1. `Initial Mark`:首先是初始化标记阶段，这个阶段是STW`(stop the world即所有线程停止工作)`，它会标记出老年代中所有的`GC Roots`以及被年轻代中存活的对象引用的对象。

![在这里插入图片描述](https://qiniuyun.sharkchili.com/img202304071111673.png)

日志范例:

![在这里插入图片描述](https://qiniuyun.sharkchili.com/img202304071111054.png)

1. `Concurrent Mark`:根据上一个阶段得到的`GC Roots`，遍历找出整个老年代中存活的对象，注意该阶段是和应用程序线程一起执行的。

![在这里插入图片描述](https://qiniuyun.sharkchili.com/img202304071111192.png)

日志范例:

![在这里插入图片描述](https://qiniuyun.sharkchili.com/img202304071111115.png)

1. `Concurrent Mark`:这个阶段也是和应用程序线程并发工作的，它会将上一阶段运行期间引用关系发生变化的对象标记为`Dirty Card`。

![在这里插入图片描述](https://qiniuyun.sharkchili.com/img202304071111707.png)

1. `Concurrent Abortable Preclean`:该阶段也是和应用程序线程并发执行的，它会尝试着去承担后续`STW`的`Final Remark`阶段的工作。

日志范例：

![在这里插入图片描述](https://qiniuyun.sharkchili.com/img202304071111708.png)

1. `Final Remark`:这个阶段是`STW`的，会标记出老年代中所有存活的对象。

日志范例

![在这里插入图片描述](https://qiniuyun.sharkchili.com/img202304071111459.png)

1. Concurrent Sweep:和应用程序线程同时进行，移除那些不需要的对象，释放空间。

![在这里插入图片描述](https://qiniuyun.sharkchili.com/img202304071111737.png)

日志范例:

![在这里插入图片描述](https://qiniuyun.sharkchili.com/img202304071111623.png)

1. `Concurrent Reset`:这个阶段并发执行，重新设置CMS算法内部的数据结构，准备下一个CMS生命周期的使用。

日志范例:

![在这里插入图片描述](https://qiniuyun.sharkchili.com/img202304071111820.png)

### [#](https://www.sharkchili.com/pages/3361b8/#问题复现)问题复现

我们现在模拟一个场景，我们的web应用中有一个定时任务，这个定时任务每隔1s会想另一个定时任务线程池中提交100个任务。

注意spring boot应用要想开启定时任务必须添加`@EnableScheduling`注解。

代码如下所示:

```java
@Component
public class Task {
    private static Logger logger = LoggerFactory.getLogger(Task.class);


    private static final ScheduledThreadPoolExecutor executor =
            new ScheduledThreadPoolExecutor(50,
                    new ThreadPoolExecutor.DiscardOldestPolicy());

	
    private static class Obj {
        private String name = "name";
        private int age = 18;
        private String gender = "man";
        private LocalDate birthday = LocalDate.MAX;

        public void func() {
            //这个方法什么也不做
        }

		//返回count个Obj对象
        private static List<Obj> getObjList(int count) {

            List<Obj> objList = new ArrayList<>(count);

            for (int i = 0; i != count; ++i) {
                objList.add(new Obj());
            }
            return objList;
        }
    }

    @Scheduled(cron = "0/1 * *  * * ? ")   //每1秒执行一次
    public void execute() {
        logger.info("1s一次定时任务");
        //向线程池提交100个任务
        Obj.getObjList(100).forEach(i -> executor.scheduleWithFixedDelay(
                i::func, 2, 3, TimeUnit.SECONDS
        ));
    }
}
```

完成后我们设置下面这段`JVM`参数后，将其启动

```java
-Xms20M -Xmx20M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps
```

不久后，控制台出现大量的`CMS GC`日志:

```java
1288.111: [GC (CMS Initial Mark) [1 CMS-initial-mark: 13695K(13696K)] 19836K(19840K), 0.0058731 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
1288.117: [CMS-concurrent-mark-start]
1288.130: [CMS-concurrent-mark: 0.013/0.013 secs] [Times: user=0.05 sys=0.02, real=0.01 secs] 
1288.130: [CMS-concurrent-preclean-start]
1288.133: [Full GC (Allocation Failure) 1288.133: [CMS1288.142: [CMS-concurrent-preclean: 0.012/0.012 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
 (concurrent mode failure): 13695K->13695K(13696K), 0.0610050 secs] 19839K->19836K(19840K), [Metaspace: 29026K->29026K(1077248K)], 0.0610521 secs] [Times: user=0.06 sys=0.00, real=0.06 secs] 
1288.258: [Full GC (Allocation Failure) 1288.258: [CMS: 13695K->13695K(13696K), 0.0612134 secs] 19839K->19836K(19840K), [Metaspace: 29026K->29026K(1077248K)], 0.0612676 secs] [Times: user=0.06 sys=0.00, real=0.06 secs] 
1288.320: [GC (CMS Initial Mark) [1 CMS-initial-mark: 13695K(13696K)] 19836K(19840K), 0.0041303 secs] [Times: user=0.03 sys=0.00, real=0.00 secs] 
1288.324: [CMS-concurrent-mark-start]
1288.339: [CMS-concurrent-mark: 0.015/0.015 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] 
1288.339: [CMS-concurrent-preclean-start]
1288.348: [CMS-concurrent-preclean: 0.009/0.009 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
1288.348: [CMS-concurrent-abortable-preclean-start]
1288.348: [CMS-concurrent-abortable-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
1288.348: [GC (CMS Final Remark) [YG occupancy: 6142 K (6144 K)]1288.348: [Rescan (parallel) , 0.0038030 secs]1288.352: [weak refs processing, 0.0000311 secs]1288.352: [class unloading, 0.0024908 secs]1288.355: [scrub symbol table, 0.0042932 secs]1288.359: [scrub string table, 0.0002748 secs][1 CMS-remark: 13695K(13696K)] 19838K(19840K), 0.0109811 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
1288.360: [CMS-concurrent-sweep-start]
1288.364: [CMS-concurrent-sweep: 0.005/0.005 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
1288.364: [CMS-concurrent-reset-start]
1288.364: [CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
1288.384: [GC (Allocation Failure) 1288.384: [ParNew: 6143K->6143K(6144K), 0.0000365 secs]1288.384: [CMS: 13695K->13695K(13696K), 0.0540105 secs] 19839K->19836K(19840K), [Metaspace: 29026K->29026K(1077248K)], 0.0541242 secs] [Times: user=0.05 sys=0.00, real=0.05 secs] 
```

### [#](https://www.sharkchili.com/pages/3361b8/#排查思路)排查思路

随着时间的推移，我们发现控制台出现了大量FULL GC`(如果是生产环境，可能服务的响应速度会非常慢)`，所以我们首先需要定位这个进程的pid，首先在控制台输入`jps`找到进程，输出如下结果，可以看到这个`pid`为`7476`。

```java
10848 KotlinCompileDaemon
4832 Jps
7476 JstackTestApplication
8856 RemoteMavenServer
```

然后我们使用`jstat`观察其`gc`情况,如下所示，可以看到每隔`10s`，就会增加大量的`FULL GC`

```java
C:\Users\xxx>jstat -gc 7476 10000 10
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
640.0  640.0   0.0   640.0   5504.0   665.5    13696.0    11176.2   31488.0 28992.6 4352.0 3889.5     39    0.084  15      0.100    0.184
640.0  640.0   0.0   640.0   5504.0   1487.2   13696.0    11176.2   31488.0 28992.6 4352.0 3889.5     39    0.084  25      0.142    0.227
640.0  640.0   0.0   640.0   5504.0   1697.8   13696.0    11176.2   31488.0 28992.6 4352.0 3889.5     39    0.084  35      0.185    0.269
640.0  640.0   0.0   640.0   5504.0   2380.4   13696.0    11176.2   31488.0 28992.6 4352.0 3889.5     39    0.084  41      0.249    0.334
640.0  640.0   0.0   640.0   5504.0   3063.0   13696.0    11176.2   31488.0 28992.6 4352.0 3889.5     39    0.084  44      0.260    0.345
640.0  640.0   0.0   640.0   5504.0   3745.6   13696.0    11176.2   31488.0 28992.6 4352.0 3889.5     39    0.084  46      0.270    0.355
640.0  640.0   0.0   640.0   5504.0   4342.6   13696.0    11176.2   31488.0 28992.6 4352.0 3889.5     39    0.084  50      0.297    0.382
```

再查看`jmap`查看堆区使用情况

```go
 jmap -heap 7476 
Attaching to process ID 26176, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.212-b10

using parallel threads in the new generation.
using thread-local object allocation.
Concurrent Mark-Sweep GC

Heap Configuration:
   MinHeapFreeRatio         = 40
   MaxHeapFreeRatio         = 70
   MaxHeapSize              = 20971520 (20.0MB)
   NewSize                  = 6946816 (6.625MB)
   MaxNewSize               = 6946816 (6.625MB)
   OldSize                  = 14024704 (13.375MB)
   NewRatio                 = 2
   SurvivorRatio            = 8
   MetaspaceSize            = 21807104 (20.796875MB)
   CompressedClassSpaceSize = 1073741824 (1024.0MB)
   MaxMetaspaceSize         = 17592186044415 MB
   G1HeapRegionSize         = 0 (0.0MB)

Heap Usage:
New Generation (Eden + 1 Survivor Space):
   capacity = 6291456 (6.0MB)
   used     = 5088288 (4.852569580078125MB)
   free     = 1203168 (1.147430419921875MB)
   80.87615966796875% used
Eden Space:
   capacity = 5636096 (5.375MB)
   used     = 5088288 (4.852569580078125MB)
   free     = 547808 (0.522430419921875MB)
   90.28036428052326% used
From Space:
   capacity = 655360 (0.625MB)
   used     = 0 (0.0MB)
   free     = 655360 (0.625MB)
   0.0% used
To Space:
   capacity = 655360 (0.625MB)
   used     = 0 (0.0MB)
   free     = 655360 (0.625MB)
   0.0% used
concurrent mark-sweep generation:
   capacity = 14024704 (13.375MB)
   used     = 13819664 (13.179458618164062MB)
   free     = 205040 (0.1955413818359375MB)
   98.53800836010514% used

12064 interned Strings occupying 1120288 bytes.
```

在排除内存泄漏的问题后，我们通过`jstack`定位进程中导致是什么对象导致老年代堆区被大量占用，如下所示可以看到前20名中的对象都是和定时任务相关，有一个`Task$Obj`对象非常抢眼，很明显就是因为它的数量过多导致的，此时我们就可以通过定位代码确定如何解决，常见方案无非是: 优化代码、增加空间两种方式，一般来说我们都会采用代码优化的方式去解决。

```java
$ jmap -histo 7476 | head -n 20

 num     #instances         #bytes  class name
----------------------------------------------
   1:         50760        3654720  java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask
   2:         30799        2901552  [C
   3:         88986        2847552  java.util.concurrent.locks.AbstractQueuedSynchronizer$Node
   4:         50700        1622400  com.example.jstackTest.Task$Obj
   5:         50760        1218240  java.util.concurrent.Executors$RunnableAdapter
   6:         50700         811200  com.example.jstackTest.Task$$Lambda$587/1605553313
   7:          6391         707928  java.lang.Class
   8:         29256         702144  java.lang.String
   9:         13577         434464  java.util.concurrent.ConcurrentHashMap$Node
  10:          6363         341016  [Ljava.lang.Object;
  11:          1722         312440  [B
  12:          3414         230424  [I
  13:             4         210680  [Ljava.util.concurrent.RunnableScheduledFuture;
  14:          5223         208920  java.util.LinkedHashMap$Entry
  15:          2297         202136  java.lang.reflect.Method
  16:          2262         193760  [Ljava.util.HashMap$Node;
  17:          5668         181376  java.util.HashMap$Node
```

而本次问题也很明显，任务是一个个提交到定时任务线程池中，是由于定时任务队列`DelayedWorkQueue`不断堆积任务导致内存被打满。所以最终改成将一个批操作一次性提交到定时任务中得以解决

```go
 @Scheduled(cron = "0/1 * *  * * ? ")   //每1秒执行一次
    public void execute() {
        logger.info("1s一次定时任务");
        //向线程池提交100个任务


        executor.scheduleWithFixedDelay(() -> {
                    Obj.getObjList(100).forEach(i -> i.func());
                }, 2, 3, TimeUnit.SECONDS
        );


    }
```

### [#](https://www.sharkchili.com/pages/3361b8/#补充-导致频繁full-gc三大原因)补充:导致频繁FULL GC三大原因

我们需要需要具体分析才能得出解决方案，总的来说原因可以分为3个:

1. 用户频繁调用`System.gc()`:这种情况需要修改代码即可，我们不该频繁调用这个方法的。
2. 老年区空间过小:视情况适当扩大空间。
3. 大对象过多:这种情况视情况决定是扩大老年代空间或者将大对象拆分。

## [#](https://www.sharkchili.com/pages/3361b8/#更多jvm调优)更多JVM调优

[从实际案例聊聊Java应用的GC优化(opens new window)](https://tech.meituan.com/2017/12/29/jvm-optimize.html)

[Java中9种常见的CMS GC问题分析与解决(opens new window)](https://tech.meituan.com/2020/11/12/java-9-cms-gc.html)

[听说 JVM 性能优化很难？今天我小试了一把！(opens new window)](https://shuyi.tech/archives/have-a-try-in-jvm-combat)

[一次线上JVM调优实践，FullGC40次/天到10天一次的优化过程(opens new window)](https://heapdump.cn/article/1859160)

[线上频繁发生Full GC 如何调优？如何快速定位OOM、cpu飙升、线程死锁等问题(opens new window)](https://blog.51cto.com/u_15281317/3008860)

## [#](https://www.sharkchili.com/pages/3361b8/#参考文献)参考文献

[JVM学习（7）Stop-The-World(opens new window)](https://www.jianshu.com/p/d686e108d15f)

[JVM调优——之CMS GC日志分析 (opens new window)](https://www.cnblogs.com/onmyway20xx/p/6590603.html)

[从实际案例聊聊Java应用的GC优化(opens new window)](https://tech.meituan.com/2017/12/29/jvm-optimize.html#:~:text= 通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor,GC的频率。 例如在相同的内存分配率的前提下，新生代中的Eden区增加一倍，Minor GC的次数就会减少一半。)

[Spring Boot定时任务详解（线程池方式）(opens new window)](https://blog.csdn.net/Alian_1223/article/details/120455623)

[SpringBoot使用@Scheduled注解实现定时任务(opens new window)](https://blog.csdn.net/pan_junbiao/article/details/109399280)

[面渣逆袭（Java 虚拟机-JVM面试题八股文）必看👍](https://tobebetterjavaer.com/sidebar/sanfene/jvm.html#_39-频繁-full-gc-怎么办)











# 图灵

**前置启动程序**

事先启动一个web应用程序，用jps查看其进程id，接着用各种jdk自带命令优化应用

**Jmap**

此命令可以用来查看内存信息，实例个数以及占用内存大小

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/EC84D5FEA98348298810AA1F885943EE/96322)

​                jmap -histo 14660  #查看历史生成的实例 jmap -histo:live 14660  #查看当前存活的实例，执行过程中可能会触发一次full gc              

打开log.txt，文件内容如下：

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/B6CBAEA18BA34FF3BC25D03D3933A7D2/96302)

- num：序号
- instances：实例数量
- bytes：占用空间大小
- class name：类名称，[C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[[I is a int[][]

堆信息

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/7273899836004DFD8921CB96ADA63635/96304)

堆内存dump

​                jmap -dump:format=b,file=eureka.hprof 14660              

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/096CD3DF5F8C465D9294E86C331013B8/96320)

也可以设置内存溢出自动导出dump文件(内存很大的时候，可能会导不出来)

1. -XX:+HeapDumpOnOutOfMemoryError
2. -XX:HeapDumpPath=./  （路径）

示例代码：

​                public class OOMTest {    public static List<Object> list = new ArrayList<>();    // JVM设置     // -Xms10M -Xmx10M -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\jvm.dump    public static void main(String[] args) {      List<Object> list = new ArrayList<>();      int i = 0;      int j = 0;      while (true) {         list.add(new User(i++, UUID.randomUUID().toString()));         new User(j--, UUID.randomUUID().toString());      }   } }              

**可以用jvisualvm命令工具导入该dump文件分析**

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/D87038046C0A4BE99461BD577017A3D4/96300)

**Jstack**

用jstack加进程id查找死锁，见如下示例

​                public class DeadLockTest {    private static Object lock1 = new Object();   private static Object lock2 = new Object();    public static void main(String[] args) {      new Thread(() -> {         synchronized (lock1) {            try {               System.out.println("thread1 begin");               Thread.sleep(5000);            } catch (InterruptedException e) {            }            synchronized (lock2) {               System.out.println("thread1 end");            }         }      }).start();       new Thread(() -> {         synchronized (lock2) {            try {               System.out.println("thread2 begin");               Thread.sleep(5000);            } catch (InterruptedException e) {            }            synchronized (lock1) {               System.out.println("thread2 end");            }         }      }).start();       System.out.println("main thread end");   } }              

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/4FB8482FD6954EB58256FFDE72FAF417/96306)

"Thread-1" 线程名 

prio=5 优先级=5

tid=0x000000001fa9e000 线程id

nid=0x2d64 线程对应的本地线程标识nid

java.lang.Thread.State: BLOCKED 线程状态

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/57C9722B794F4473AAEBFA92831214B2/96308)

还可以用jvisualvm自动检测死锁

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/107CD682F0F34039AC2AB686766D2FF4/96309)

 **远程连接jvisualvm**

**启动普通的jar程序JMX端口配置：**

​                java -Dcom.sun.management.jmxremote.port=8888 -Djava.rmi.server.hostname=192.168.65.60 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -jar microservice-eureka-server.jar              

PS：

-Dcom.sun.management.jmxremote.port 为远程机器的JMX端口

-Djava.rmi.server.hostname 为远程机器IP

**tomcat的JMX配置：在catalina.sh文件里的最后一个JAVA_OPTS的赋值语句下一行增加如下配置行**

​                JAVA_OPTS="$JAVA_OPTS -Dcom.sun.management.jmxremote.port=8888 -Djava.rmi.server.hostname=192.168.50.60 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false"              

连接时确认下端口是否通畅，可以临时关闭下防火墙

​                systemctl stop firewalld   #临时关闭防火墙              

**jstack找出占用cpu最高的线程堆栈信息**

​                package com.tuling.jvm; /** * 运行此代码，cpu会飙高 */ public class Math {     public static final int initData = 666;    public static User user = new User();     public int compute() {  //一个方法对应一块栈帧内存区域        int a = 1;        int b = 2;        int c = (a + b) * 10;        return c;    }     public static void main(String[] args) {        Math math = new Math();        while (true){            math.compute();        }    } }              

1，使用命令top -p  ，显示你的java进程的内存情况，pid是你的java进程号，比如19663

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/95F189D34BB34C09816B6D95CAB62005/96310)

2，按H，获取每个线程的内存情况 

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/449A8C6C90F647818D9B15E279F8DACE/96324)

3，找到内存和cpu占用最高的线程tid，比如19664

4，转为十六进制得到 0x4cd0，此为线程id的十六进制表示 （top看的是操作系统的线程，而jstack中展示线程时，操作系统线程展示的是16进制，所以要进行装换）

5，执行 jstack 19663|grep -A 10 4cd0，得到线程堆栈信息中 4cd0 这个线程所在行的后面10行，从堆栈中可以发现导致cpu飙高的调用方法

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/90A784EAB9894E209E9161B7C17096F5/96326)

6，查看对应的堆栈信息找出可能存在问题的代码

**Jinfo** 

查看正在运行的Java应用程序的扩展参数 

查看jvm的参数

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/EB491F1E07ED4209A8F340C30CE09027/96331)

查看java系统参数

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/D45E5DDE7D044A1FBC74178FB106D34A/96333)

**Jstat**

jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下：

jstat [-命令选项] [vmid] [间隔时间(毫秒)] [查询次数]

注意：使用的jdk版本是jdk8

垃圾回收统计

**jstat -gc pid 最常用**，可以评估程序内存使用及GC压力整体情况

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/A1CCAEEFC56D4EE387D7EC6348C6F8BB/96314)

- S0C：第一个幸存区的大小，单位KB
- S1C：第二个幸存区的大小
- S0U：第一个幸存区的使用大小
- S1U：第二个幸存区的使用大小
- EC：伊甸园区的大小
- EU：伊甸园区的使用大小
- OC：老年代大小
- OU：老年代使用大小
- MC：方法区大小(元空间)
- MU：方法区使用大小
- CCSC:压缩类空间大小
- CCSU:压缩类空间使用大小
- YGC：年轻代垃圾回收次数
- YGCT：年轻代垃圾回收消耗时间，单位s
- FGC：老年代垃圾回收次数 
- FGCT：老年代垃圾回收消耗时间，单位s
- GCT：垃圾回收消耗总时间，单位s

堆内存统计

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/B82BD98F97C84A2EB0A7EA2AC86EF606/96312)

- NGCMN：新生代最小容量
- NGCMX：新生代最大容量
- NGC：当前新生代容量
- S0C：第一个幸存区大小
- S1C：第二个幸存区的大小
- EC：伊甸园区的大小
- OGCMN：老年代最小容量
- OGCMX：老年代最大容量
- OGC：当前老年代大小
- OC:当前老年代大小
- MCMN:最小元数据容量
- MCMX：最大元数据容量
- MC：当前元数据空间大小
- CCSMN：最小压缩类空间大小
- CCSMX：最大压缩类空间大小
- CCSC：当前压缩类空间大小
- YGC：年轻代gc次数
- FGC：老年代GC次数

新生代垃圾回收统计

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/8FECFAF1EE994EBBAEB93E1BA7E87AC9/96317)

- S0C：第一个幸存区的大小
- S1C：第二个幸存区的大小
- S0U：第一个幸存区的使用大小
- S1U：第二个幸存区的使用大小
- TT:对象在新生代存活的次数
- MTT:对象在新生代存活的最大次数
- DSS:期望的幸存区大小
- EC：伊甸园区的大小
- EU：伊甸园区的使用大小
- YGC：年轻代垃圾回收次数
- YGCT：年轻代垃圾回收消耗时间

新生代内存统计

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/8E0C8BC666064276AA8CEA80BA60D219/96315)

- NGCMN：新生代最小容量
- NGCMX：新生代最大容量
- NGC：当前新生代容量
- S0CMX：最大幸存1区大小
- S0C：当前幸存1区大小
- S1CMX：最大幸存2区大小
- S1C：当前幸存2区大小
- ECMX：最大伊甸园区大小
- EC：当前伊甸园区大小
- YGC：年轻代垃圾回收次数
- FGC：老年代回收次数

老年代垃圾回收统计

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/390D87E5743D48BF9CA052A6E8652D46/96319)

- MC：方法区大小
- MU：方法区使用大小
- CCSC:压缩类空间大小
- CCSU:压缩类空间使用大小
- OC：老年代大小
- OU：老年代使用大小
- YGC：年轻代垃圾回收次数
- FGC：老年代垃圾回收次数
- FGCT：老年代垃圾回收消耗时间
- GCT：垃圾回收消耗总时间

老年代内存统计

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/B529A9B7E2404516942E67285253771F/96318)

- OGCMN：老年代最小容量
- OGCMX：老年代最大容量
- OGC：当前老年代大小
- OC：老年代大小
- YGC：年轻代垃圾回收次数
- FGC：老年代垃圾回收次数
- FGCT：老年代垃圾回收消耗时间
- GCT：垃圾回收消耗总时间

元数据空间统计

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/E25CDA3658324BD6B9E13985209D566D/96316)

- MCMN:最小元数据容量
- MCMX：最大元数据容量
- MC：当前元数据空间大小 
- CCSMN：最小压缩类空间大小
- CCSMX：最大压缩类空间大小
- CCSC：当前压缩类空间大小
- YGC：年轻代垃圾回收次数
- FGC：老年代垃圾回收次数
- FGCT：老年代垃圾回收消耗时间
- GCT：垃圾回收消耗总时间

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/A4241648D94C49E994C970E5C2FA9EED/96321)

- S0：幸存1区当前使用比例
- S1：幸存2区当前使用比例
- E：伊甸园区使用比例
- O：老年代使用比例
- M：元数据区使用比例
- CCS：压缩使用比例
- YGC：年轻代垃圾回收次数
- FGC：老年代垃圾回收次数
- FGCT：老年代垃圾回收消耗时间
- GCT：垃圾回收消耗总时间

**JVM运行情况预估**

用 jstat gc -pid 命令可以计算出如下一些关键数据，有了这些数据就可以采用之前介绍过的优化思路，先给自己的系统设置一些初始性的JVM参数，比如堆内存大小，年轻代大小，Eden和Survivor的比例，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值等。

**年轻代对象增长的速率**

可以执行命令 jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)，通过观察EU(eden区的使用)来估算每秒eden大概新增多少对象，如果系统负载不高，可以把频率1秒换成1分钟，甚至10分钟来观察整体情况。注意，一般系统可能有高峰期和日常期，所以需要在不同的时间分别估算不同情况下对象增长速率。

**Young GC的触发频率和每次耗时**

知道年轻代对象增长速率我们就能推根据eden区的大小推算出Young GC大概多久触发一次，Young GC的平均耗时可以通过 YGCT/YGC 公式算出，根据结果我们大概就能知道**系统大概多久会因为Young GC的执行而卡顿多久。**

**每次Young GC后有多少对象存活和进入老年代**

这个因为之前已经大概知道Young GC的频率，假设是每5分钟一次，那么可以执行命令 jstat -gc pid 300000 10 ，观察每次结果eden，survivor和老年代使用的变化情况，在每次gc后eden区使用一般会大幅减少，survivor和老年代都有可能增长，这些增长的对象就是每次Young GC后存活的对象，同时还可以看出每次Young GC后进去老年代大概多少对象，从而可以推算出**老年代对象增长速率。**

**Full GC的触发频率和每次耗时**

知道了老年代对象的增长速率就可以推算出Full GC的触发频率了，Full GC的每次耗时可以用公式 FGCT/FGC 计算得出。

**优化思路**其实简单来说就是尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。

**系统频繁Full GC导致系统卡顿是怎么回事**

- 机器配置：2核4G
- JVM内存大小：2G
- 系统运行时间：7天
- 期间发生的Full GC次数和耗时：500多次，200多秒
- 期间发生的Young GC次数和耗时：1万多次，500多秒

大致算下来每天会发生70多次Full GC，平均每小时3次，每次Full GC在400毫秒左右；

每天会发生1000多次Young GC，每分钟会发生1次，每次Young GC在50毫秒左右。

JVM参数设置如下：

​                -Xms1536M -Xmx1536M -Xmn512M -Xss256K -XX:SurvivorRatio=6  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:+UseParNewGC  -XX:+UseConcMarkSweepGC  -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly               

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/4AD3574884C54C7DBF8836737492178E/96307)

大家可以结合**对象挪动到老年代那些规则**推理下我们这个程序可能存在的一些问题

经过分析感觉可能会由于对象动态年龄判断机制导致full gc较为频繁

为了给大家看效果，我模拟了一个示例程序(见课程对应工程代码：jvm-full-gc)，打印了jstat的结果如下：

​                jstat -gc 13456 2000 10000              

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/CE415B441097490B978044442055038E/96359)

对于对象动态年龄判断机制导致的full gc较为频繁可以先试着优化下JVM参数，把年轻代适当调大点：

​                -Xms1536M -Xmx1536M -Xmn1024M -Xss256K -XX:SurvivorRatio=6  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:+UseParNewGC  -XX:+UseConcMarkSweepGC  -XX:CMSInitiatingOccupancyFraction=92 -XX:+UseCMSInitiatingOccupancyOnly               

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/AECFE82FDD864C5AAB6F00E8ADD7BF65/96350)

优化完发现没什么变化，**full gc的次数比minor gc的次数还多了**

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/AE64076329DD43228B9B6F159074BFAC/96366)

我们可以推测下full gc比minor gc还多的原因有哪些？

1、元空间不够导致的多余full gc

2、显示调用System.gc()造成多余的full gc，这种一般线上尽量通过-XX:+DisableExplicitGC参数禁用，如果加上了这个JVM启动参数，那么代码中调用System.gc()没有任何效果

3、老年代空间分配担保机制

最快速度分析完这些我们推测的原因以及优化后，我们发现young gc和full gc依然很频繁了，而且看到有大量的对象频繁的被挪动到老年代，这种情况我们可以借助jmap命令大概看下是什么对象

​    ![0](https://note.youdao.com/yws/public/resource/5cc182642eb02bc64197788c7722baae/xmlnote/4C7F5860756B4F4B988D54121764E082/96303)

查到了有大量User对象产生，这个可能是问题所在，但不确定，还必须找到对应的代码确认，如何去找对应的代码了？

1、代码里全文搜索生成User对象的地方(适合只有少数几处地方的情况)

2、如果生成User对象的地方太多，无法定位具体代码，我们可以同时分析下占用cpu较高的线程，一般有大量对象不断产生，对应的方法代码肯定会被频繁调用，占用的cpu必然较高

可以用上面讲过的jstack或jvisualvm来定位cpu使用较高的代码，最终定位到的代码如下：

​                import java.util.ArrayList; @RestController public class IndexController {     @RequestMapping("/user/process")    public String processUserData() throws InterruptedException {        ArrayList<User> users = queryUsers();         for (User user: users) {            //TODO 业务处理            System.out.println("user:" + user.toString());        }        return "end";    }     /**     * 模拟批量查询用户场景     * @return     */    private ArrayList<User> queryUsers() {        ArrayList<User> users = new ArrayList<>();        for (int i = 0; i < 5000; i++) {            users.add(new User(i,"zhuge"));        }        return users;    } }              

同时，java的代码也是需要优化的，一次查询出500M的对象出来，明显不合适，要根据之前说的各种原则尽量优化到合适的值，尽量消除这种朝生夕死的对象导致的full gc

**内存泄露到底是怎么回事**

再给大家讲一种情况，一般电商架构可能会使用多级缓存架构，就是redis加上JVM级缓存，大多数同学可能为了图方便对于JVM级缓存就简单使用一个hashmap，于是不断往里面放缓存数据，但是很少考虑这个map的容量问题，结果这个缓存map越来越大，一直占用着老年代的很多空间，时间长了就会导致full gc非常频繁，这就是一种内存泄漏，对于一些老旧数据没有及时清理导致一直占用着宝贵的内存资源，时间长了除了导致full gc，还有可能导致OOM。

这种情况完全可以考虑采用一些成熟的JVM级缓存框架来解决，比如ehcache等自带一些LRU数据淘汰算法的框架来作为JVM级的缓存。
