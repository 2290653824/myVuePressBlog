> 本文试图用一句话+一张图说清楚操作系统中的银行家算法。我相信用一句话可以讲清楚一个算法的核心思想，一张图可以描述整个算法的操作步骤。但本人能力有限，错误之处望大家指出，多谢。

### 一句话：
当一个进程申请使用资源的时候，银行家算法通过先 试探 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。

> 那么此时会有一个问题，如何判断系统是否处于安全状态？算法流程将用下面一张图来表示。

### 一张图

![image-20230811143115627](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230811143115627.png)

- 首先是银行家算法中的进程：
  包含进程Pi的需求资源数量（也是最大需求资源数量，MAX）
  已分配给该进程的资源A（Allocation）
  还需要的资源数量N（Need=M-A）

- Available为空闲资源数量，即资源池（注意：资源池的剩余资源数量+已分配给所有进程的资源数量=系统中的资源总量）

假设资源P1申请资源，银行家算法先试探的分配给它（当然先要看看当前资源池中的资源数量够不够），若申请的资源数量小于等于Available，然后接着判断分配给P1后剩余的资源，能不能使进程队列的某个进程执行完毕，若没有进程可执行完毕，则系统处于不安全状态（即此时没有一个进程能够完成并释放资源，随时间推移，系统终将处于死锁状态）。

若有进程可执行完毕，则假设回收已分配给它的资源（剩余资源数量增加），把这个进程标记为可完成，并继续判断队列中的其它进程，**若所有进程都可执行完毕，则系统处于安全状态，并根据可完成进程的分配顺序生成安全序列（如{P0，P3，P2，P1}表示将申请后的剩余资源Work先分配给P0–>回收（Work+已分配给P0的A0=Work）–>分配给P3–>回收（Work+A3=Work）–>分配给P2–>······满足所有进程）。**

如此就可避免系统存在潜在死锁的风险。

### 来个例子
在银行家算法中，若出现下述资源分配情况：

![image-20230811143147405](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230811143147405.png)

> 注：题中共四种资源，P0的Allocation为（0，0，3，2）表示已分配给P0的第一种资源和第二种资源为0个，第三种资源3个，第四种资源2个。

（1）该状态是否安全？ （2）若进程P2提出请求Request（1，2，2，2）后，系统能否将资源分配给它？

（1）利用安全性算法对上面的状态进行分析（见下表），找到了一个安全序列{P0,P3,P4,P1,P2}，故系统是安全的。

![image-20230811143209735](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230811143209735.png)


（2）P2发出请求向量Request(1,2,2,2),系统按银行家算法进行检查：

①Request2(1,2,2,2)<=Need2(2,3,5,6)
②Request2(1,2,2,2)<=Available(1,6,2,2)
③系统先假定可为P2分配资源，并修改Available，Allocation2和Need2向量：
Available=(0,4,0,0)
Allocation2=(2,5,7,6)
Need2=(1,1,3,4)
此时再进行安全性检查，发现 Available=(0,4,0,0) 不能满足任何一个进程，所以判定系统进入不安全状态，即不能分配给P2相应的Request(1,2,2,2)。
