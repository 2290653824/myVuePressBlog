

## 一. k8s整体架构

  ![img](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/v2-c571e81ab75e16ecb667aa1edfc7e5ee_720w.webp)

### 1. kubectl 

kubectl是与Kubernetes集群进行交互的主要方式之一，它允许用户通过命令行界面执行各种操作，如创建、删除和管理容器、Pod、服务、部署等。



kubectl主要与Kubernetes中的`kube-apiserver`组件进行交互。`kube-apiserver`是Kubernetes的控制平面组件之一，它充当了Kubernetes API 的前端，处理所有对Kubernetes集群的API请求。

当您在kubectl中运行命令时，例如创建、更新、删除资源或者获取集群状态，kubectl会将请求发送到`kube-apiserver`。`kube-apiserver`负责验证请求、执行相应的操作，并返回结果给kubectl。这种方式使得kubectl可以通过统一的命令行界面与整个Kubernetes集群进行交互。

除了与`kube-apiserver`进行交互之外，kubectl还可能与其他组件进行通信，如`kube-controller-manager`、`kube-scheduler`、`kubelet`等，但这些组件通常是在集群内部自动进行通信和协调的，而不是直接通过kubectl进行操作的。



### 2. Kubernetes Dashboard

Kubernetes Dashboard是一个用于可视化和管理Kubernetes集群的Web用户界面。它提供了一个用户友好的界面，通过它，用户可以查看集群中的各种资源、进行部署、监视应用程序状态、调试问题以及执行其他与集群相关的任务，而无需使用命令行工具



当用户在dashboard上面进行操作时，会将相关的指令交给kube-apiServer，在由apiServer进行其他操作的传输。





### 3. Master节点

k8s master节点【控制面板】

#### Api-server

#### kube-Controller-manager 

管理各个类型的控制器，针对k8s中的各种资源进行管理

#### cloud-controller-manager 

云控制器管理器，第三方云平台提供的控制器api对接管理控制【第三方云平台】

#### kube-schedule

调度器 负责将pod基于一定的算法，将其调用到更合适的节点（服务器）上。举例：我现在有一个mysql的容器，而mysql需要存储能力比较强的机器，schedule就来决定这个mysql容器会分配到哪个服务器上。

#### etcd

k8s自己的数据库kv，分布式数据库。提供基于raft算法实现自主的集群高可用。【老版本：基于内存；新版本：持久化存储】

### 4. node节点

#### kubelet 

kubelet是Kubernetes集群中的一个关键组件，它运行在每个节点上，负责管理该节点上的容器和Pod。kubelet确保在节点上创建、启动、停止和监视Pod，以及与控制平面组件交互以维持所需的状态。负责Pod的声明周期和存储管理、网络

#### kube-proxy 

`kube-proxy`是Kubernetes集群中的一个网络代理组件，它运行在每个节点上，负责处理网络流量的路由和负载均衡。`kube-proxy`的主要作用是维护节点上的网络规则，以确保从集群外部或集群内部访问服务时能够正确地将请求路由到正确的Pod。

网络代理，负责server的服务发现和负载均衡（4层：网络层，iptables）



#### container-runtime

 容器的运行时环境：docker、containerd、CRI-O【可以从多个当中选一个容器方案】

#### pod

运行了容器1、容器2、容器3。至少要有一个容器。【一台服务器是一个节点，一个节点下有多个pod，每一个pod下可以运行多个容器】

![Components of Kubernetes](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/components-of-kubernetes.svg)

![image-20230825144701160](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825144701160.png)

> 一个master、多个节点
>
> apiServer、pod是核心



### 附加的一些组件

kube-dns 为整个集群提供DNS服务

Ingress Controller 让外部网络可以访问一个节点里的pod

heapster 资源监控（也可以用普罗米修斯）

dashboard

federation 跨集群

es 日志存储



> 以上可参考官方文档:[Kubernetes Components](https://kubernetes.io/docs/concepts/overview/components/)



## 二.k8s的分层架构

![image-20230825145112805](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825145112805.png)

- 核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境。

  > 核心层里面放的是最最核心的那些对象，提供最核心的API，比如 POD、NODE、 SERVICE、NAMESPACE等，就是运行一个应用的一些最基本对象

- 应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析 等）。

  > 主要解决面向不同的应用。我应该去怎么样去抽象它的部署和服务发现？
  >
  > 对于无状态应用来说就 deployment
  >
  > 对于有状态应用来说是 statefulSet
  >
  > 批处理作业 job
  >
  > 。。。

- 管理层：系统度量（如基础设施、容器和网络的度量）、自动化（如自动扩展、动态 Provision 等）、 策略管理（RBAC、Quota、PSP、NetworkPolicy 等）。

  > 主机解决更高级的需求， 如 隔离需求，安全需求，配额控制需求，自动的扩缩容的能力等

- 接口层：Kubectl 命令行工具、客户端 SDK 以及集群联邦。

- 生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴：

  - Kubernetes 外部：日志、监控、配置管理、CI、CD、Workflow、FaaS、OTS 应用、 ChatOps 等；
  - Kubernetes 内部：CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等。



## 三. 服务分类

![image-20230825145259165](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825145259165.png)

### 有状态服务

对本地的存储系统会有依赖，如果要进行扩容，则还需要拷贝存储系统才行。

有状态服务是需要保持状态的应用，它们可能保存会话信息、数据库状态或其他需要持久化的状态数据。每个实例可能具有唯一标识或状态。有状态服务的特点包括：

1. **固定标识：** 每个实例有一个唯一的标识，如稳定的网络名称或主机名。这是因为有状态服务需要在实例之间保持一致的状态。【例如标识mysql主库和从库】
2. **持久化存储：** 有状态服务通常需要持久化存储来保存状态数据。这可以是网络存储、分布式数据库等。
3. **有序扩展：** 有状态服务的扩展可能需要考虑数据一致性和顺序，因此扩展和管理可能相对复杂。

常见的有状态服务包括数据库、缓存存储、消息队列等。

总之，在Kubernetes中，根据应用的状态要求，您可以选择部署无状态服务或有状态服务。无状态服务更容易扩展和管理，而有状态服务通常需要考虑更多的数据一致性和持久性问题。Kubernetes提供了适应这两种服务类型的机制和资源，以便满足不同应用的需求。



### 无状态服务

无状态服务也称为无状态应用，它们不依赖于特定的节点或实例来存储会话或状态信息。每个请求可以独立地处理，无需了解之前的请求状态。无状态服务的特点包括：

1. **水平扩展：** 由于无状态服务不保存状态，可以简单地通过增加实例数量来实现水平扩展，从而应对更高的负载。
2. **易于替换和管理：** 无状态服务的实例可以随时替换，因为它们没有持久化的状态。这使得部署、更新和管理变得更加容易。
3. **不需要持久化存储：** 由于没有需要持久化的状态，无状态服务通常不需要长期存储数据。

常见的无状态服务包括 Web 应用程序、API 服务和微服务。





## 四. 基础概念

### 1. 资源与对象

  Kubernetes 中的所有内容都被抽象为“资源”，如 Pod、Service、Node 等都是资源。“对象”就是“资源”的实例，是持久化的实体。如某个具体的 Pod、某个具体的 Node。Kubernetes 使用这些实体去表示整个集群的状态。
  对象的创建、删除、修改都是通过 “Kubernetes API”，也就是 “Api Server” 组件提供的 API 接口，这些是 RESTful 风格的 Api，与 k8s 的“万物皆对象”理念相符。命令行工具 “kubectl”，实际上也是调用 kubernetes api。
  K8s 中的资源类别有很多种，kubectl 可以通过配置文件来创建这些 “对象”，配置文件更像是描述对象“属性”的文件，配置文件格式可以是 “JSON” 或 “YAML”，常用 “YAML”。





### 2. 对象规约spec和状态status

  对象是用来完成一些任务的，是持久的，是有目的性的，因此 kubernetes 创建一个对象后，将持续地工作以确保对象存在。当然，kubernetes 并不只是维持对象的存在这么简单，kubernetes 还管理着对象的方方面面。每个Kubernetes对象包含两个嵌套的对象字段，它们负责管理对象的配置，他们分别是 “spec” 和 “status” 。

- “spec” 是 “规约”、“规格” 的意思，spec 是必需的，它描述了对象的期望状态（Desired State）—— 希望对象所具有的特征。当创建 Kubernetes 对象时，必须提供对象的规约，用来描述该对象的期望状态，以及关于对象的一些基本信息（例如名称）。以 Pod 为例，如下是一个简单的创建 Pod 的 yaml 文件模板:

  ```yaml
  apiVersion: v1
  kind: Pod
  metadata:
      name: myapp-pod
      labels:
        app: myapp
  spec:
      containers:
      - name: myapp-container
        image: busybox
        command: ['sh', '-c', 'echo Hello Kubernetes! && sleep 3600']
  ```

上面的模板描述了一个对象，对象的类型是 “Pod”，对象名为 “myapp-pod”，包含一个 “app: myapp” 标签。“spec” 指定了该 Pod 对象的特征——对象包含一个名为 “myapp-container” 的容器，容器根据 “busybox” 镜像生成，容器运行的命令是 “ ['sh', '-c', 'echo Hello Kubernetes! && sleep 3600'] ”。

> 除 “spec” 字段外，在创建一个Pod及Pod的控制器对象时，还要像上面模板所示一样，还要有这三个字段:
> “apiVersion”——“创建该对象所使用的 Kubernetes API 的版本”；
> “kind”——“想要创建的对象的类型”；
> “metadata”——“帮助识别对象唯一性的数据，包括一个 name 字符串、UID 和可选的 namespace。”

- status 描述了对象的 实际状态（Actual State） ，它是由 Kubernetes 系统提供和更新的。在任何时刻，Kubernetes 控制面一直努力地管理着对象的实际状态以与期望状态相匹配。



上面的内容参考:[Kubernetes资源与对象简述](https://www.cnblogs.com/life-of-coding/p/12156685.html)





### 3.资源的分类

#### 元数据

>对于资源的元数据描述，每个资源都可以使用元空间的数据

Horizontal Pod Autoscalar (HPA)  【pod自动伸缩】

![image-20230825152518162](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825152518162.png)

PodTemplate

![image-20230825152725395](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825152725395.png)



LimitRange

![image-20230825152823920](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825152823920.png)

如通过HPA进行自动伸缩时，根据podTemplate进行pod的创建，并通过limitrange来限制pod资源的使用







#### 集群

> 集群资源的空间，作用于集群之上，集群下的所有的资源都是可以共享使用的。就例如一个进程，进程下的资源线程都可以享用

namespace

node

![image-20230825153117884](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825153117884.png)

clusterRole 对集群权限进行管理

ClusterRolebing 绑定角色与资源进行绑定，都是集群集群上的权限管理





#### **命名空间**

> 一个集群下可以有多个命名空间，命名空间内的资源可以共享，不同命名空间之间的数据不能进行共享

- 工作负载型

**Pod**：

![image-20230825154810882](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825154810882.png)

![image-20230825154829062](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825154829062.png)



![image-20230825154922810](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825154922810.png)



![image-20230825155101676](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825155101676.png)



pod控制器

用来控制pod怎么来创建

无状态

ReplicationController RC【新版本已经废除】

可以帮助我们动态的去完成pod的扩容和缩容。根据用于定义的副本数量

缺点：需要rc与pod进行绑定，很麻烦

ReplicaSet（RS) 

![image-20230825160122969](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825160122969.png)

可以通过selector来选择对哪些pod生效，即可以选择多个不通话的pod

![image-20230825160558480](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825160558480.png)

label

selector

**Deployment**

RC和RS只有扩容和缩容，这是不够的。

对RS进行了再次的封装。提供了更多部署的特性。

> - 创建rs，pod
>
> 用户可以根据dm创建pod，dm会自动帮助我们创建rs
>
> - 平滑扩容和缩容
>
> ![image-20230825161601001](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825161601001.png)
>
> 原来的rs控制的为APP2两个，当我们进行升级的服务时，dy会创建自动创建一个新的rs2，rs2复制一个app2并启动，同时关掉rs1的一个APP2，实现平滑更新
>
> - 暂停和恢复
> - 回滚





有状态

statefulSet

![image-20230825161908003](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825161908003.png)

![image-20230825162406252](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825162406252.png)

- headless Service 

DNS管理

- volumeClaimTemplate

用于持久化卷的模版





守护进程

DaemonSet

![image-20230825162724300](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825162724300.png)

任务/定时

job

cronJob







> 在Kubernetes中，"元数据"、"集群"和"命名空间"是三个重要的概念，用于管理和组织集群中的资源。
>
> 1. **元数据（Metadata）**: 在Kubernetes中，元数据是关于各种资源（如Pods、Services、Deployments等）的描述性信息。这些信息包括资源的名称、标签、注释、创建时间、命名空间等。元数据帮助用户和系统理解资源的属性和上下文，有助于对资源进行管理、查询和监控。
> 2. **集群（Cluster）**: Kubernetes集群是由多个物理或虚拟计算机（节点）组成的集合，用于运行容器化应用程序。这些节点可以分布在不同的主机上，并且由Kubernetes进行管理和编排。集群包括控制平面（主节点）和工作节点。控制平面负责管理和控制集群中的资源，而工作节点负责运行实际的容器和应用程序。
> 3. **命名空间（Namespace）**: 命名空间是Kubernetes中用于对资源进行隔离和分组的机制。通过将资源放置在不同的命名空间中，可以将不同的团队、项目或应用程序隔离开来，以避免冲突和资源干扰。同一种类型的资源（如Pods、Services等）可以在不同的命名空间中具有相同的名称，而不会产生冲突。命名空间还有助于对资源进行权限控制和资源配额设置。
>
> 总之，元数据是描述性信息，集群是由节点组成的容器化应用程序环境，命名空间是用于隔离和组织资源的分组机制。这些概念共同帮助Kubernetes用户有效地管理和操作他们的应用程序和服务。

![image-20230825151710499](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825151710499.png)



可参考：[k8s资源的分类](https://juejin.cn/post/7152689923844210719)



## 五. K8S集群搭建

集群搭建：

![image-20230825163054340](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825163054340.png)

此次搭建方案使用 kubeadm方式：

![image-20230825164134100](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230825164134100.png)









### 1. 初始操作

```shell
# 关闭防火墙
systemctl stop firewalld
systemctl disable firewalld

# 关闭selinux
set -i 's/enforcing/disable' /etc/selinux/config # 永久
setenforce 0 #临时

# 关闭swap
swapoff -a #临时
sed -ri 's/.*swap.*/#&/' /etc/fstab #永久

# 关闭完swap后，一定要重启下虚拟机

# 根据规划设置主机名
hostnamectl set-hostname <hostname>

# 在master添加hosts
cat >> /etc/hosts << EOF
192.168.113.120 k8s-master
192.168.113.121 k8s-node1
192.168.113.122 k8s-node2
EOF

# 将桥接的IPV4流量传递到iptables的链
cat > /etc/sysctl.d/k8s.conf << EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF

sysctl --system # 生效

# 时间同步
yum install ntpdate -y
ntpdate time.windows.com

```



### 2. 安装基础软件 基于ubuntu 20.04.1

#### 安装docker

```shell
```

[ubuntu 安装](https://zhuanlan.zhihu.com/p/143156163)

#### 添加阿里云yum源



#### 安装kubeadm、kubelet、kubectl

- `kubeadm`：用来初始化集群的指令。
- `kubelet`：在集群中的每个节点上用来启动 Pod 和容器等。
- `kubectl`：用来与集群通信的命令行工具。

```shell
snap install kubectl --classic
snap install kubelet --classic
snap install kubeadm --classic
```





#### 初始化集群

```shell
kubeadm init \
	--apiserver-advertise-address=122.228.207.18 \
	--image-repository registry.aliyuncs.com/google_containers \
	--kubernetes-version=v1.28.0 \
	--service-cidr=10.96.0.0/12 \
	--pod-network-cidr=10.244.0.0/16
```





使用kubeadm的踩坑记录

docker version 24.0.5

kubeadm kubectl kubelet 1.28.1-00

当使用kubeadm初始化集群时出现问题:

```shell
validate service connection: CRI v1 runtime API is not implemented for endpoint
```

从网上翻阅资料：

https://serverfault.com/questions/1118051/failed-to-run-kubelet-validate-service-connection-cri-v1-runtime-api-is-not-im

似乎是在k8s的1.26版本，k8s需要对应的容器提供CRI版本，而如果使用最新版本的k8s，而最新版的docker并没有提供合适的CRI接口，所以就会出现上述的问题



查询gpt

```shell
kubeadm init 报错container runtime is not running: output: time="2023-08-28T10:19:21+08:00" level=fatal msg="validate service connection: CRI v1 runtime API is not implemented for endpoint \"unix:///var/run/containerd/containerd.sock\": rpc error: code = Unimplemented desc = unknown service runtime.v1.RuntimeService"
怎么解决
```

```shell
检查 CRI 版本和配置： 确保 kubeadm init 与容器运行时的 CRI 版本兼容。不同的 Kubernetes 版本可能需要特定版本的 CRI。同时，确保 Kubernetes 集群配置中指定了正确的 CRI 配置。
```

所以需要确定k8s的版本和docker的版本合适才行，通过一下的命令将版本进行更换

```shell
首先需要查看当前的组件的版本

apt-get list --installed | grep kubectl
apt-get list --installed | grep kubelet
apt-get list --installed | grep kubeadm

docker version
```

我当时以上的版本为

```shell
docker version 24.0.5

kubeadm kubectl kubelet 1.28.1-00
```

现在我根据相关的文档查看k8s需要哪个docker

https://blog.csdn.net/M82_A1/article/details/98872734

并借鉴了下面的安装文档

https://blog.csdn.net/yy8623977/article/details/124685772



最终决定使用k8s版本：1.23.6

docker版本：20.10

卸载原有版本

```shell
sudo apt-get remove kubeadm kubectl kubelet
sudo apt-get install kubeadm=1.23.6 kubectl=1.23.6 kubelet=1.23.6
sudo apt-mark hold kubeadm
```

如何降级docker

https://blog.csdn.net/hunter1000/article/details/122872247





以上都成功后，我们需要安装kubeadm的镜像

```shell
kubeadm config images list
```

```shell
k8s.gcr.io/kube-apiserver:v1.23.6
k8s.gcr.io/kube-controller-manager:v1.23.6
k8s.gcr.io/kube-scheduler:v1.23.6
k8s.gcr.io/kube-proxy:v1.23.6
k8s.gcr.io/pause:3.6
k8s.gcr.io/etcd:3.5.1-0
k8s.gcr.io/coredns/coredns:v1.8.6
```

调用k8s.gcr.io的连通性,发现我发联通，我们看看官网的解释

https://kubernetes.io/zh-cn/blog/2023/03/10/image-registry-redirect/





### minikube 方式

直接看官网：[https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)



kubectl命令：https://kubernetes.io/docs/reference/kubectl/

https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands



![image-20230828155609282](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230828155609282.png)



kubectl get pod 获取相关的pod信息

Kubectl get pod -o wide

kubectl get deploy 获取deploy相关信息

kubectl scale --help 扩容命令的帮助

kubectl scale --replicas=3 pod名字 `创建某个pod的三个副本`



kubectl get namespace 获得命名空间



kubectl get deploy 名字 -o yaml

kubectl get pods 获取所有pod



k8s api概述

![image-20230828164141639](/Users/zhengjian/Library/Application Support/typora-user-images/image-20230828164141639.png)

api版本规则



## 六.Pod深入解析

![image-20230828165016107](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230828165016107.png)

资源清单的编写：https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/assign-memory-resource/

```shell
apiVersion： 指定资源对象所属的 API 版本。它决定了 Kubernetes 如何解析和处理资源清单。例如，apiVersion: v1 表示使用的是 Kubernetes 的核心 API。

kind： 定义资源对象的类型。它指示 Kubernetes 要创建的资源类型，例如 kind: Pod、kind: Service 等。

metadata： 元数据字段包含了关于资源的信息，如名称、命名空间、标签等。

name： 资源的名称。
namespace： 资源所属的命名空间（Namespace）。如果未指定，默认为 default 命名空间。
labels： 标签用于标识资源，并可用于筛选和分组。
annotations： 注解用于添加描述性信息，通常用于记录额外的元数据。
spec： spec 部分是资源的规格，包含了资源配置的详细信息。

根据资源类型的不同，spec 部分的内容也不同，例如：

Pod： spec 包含容器和卷的配置。
Service： spec 定义了服务的类型、端口和选择器等。
Deployment： spec 定义了部署的副本数、容器映像、卷等。
status： status 部分包含了关于资源当前状态的信息。这是 Kubernetes 控制器设置的字段，用于记录资源的实际状态，通常由 Kubernetes 自己管理。
```

> ![image-20230828171659188](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230828171659188.png)



创建好了过后使用`kubectl create -f 文件`进行创建

后我们可以使用kubectl get po 查看相关的pod信息，还可以使用kubectl describe po po名字查看具体的信息。

```shell
apiVersion: v1
kind: Pod
metadata:
  name: nginx-demo
  labels:
    type: "1"
    version: "1"
  namespace: default
spec:
  containers:
  - name: nginx
    image: nginx:1.7.9
    imagePullPolicy: IfNotPresent
    command: 
    - nginx
    - -g
    - "daemon off;"
    workingDir: "/usr/share/nginx/html"
    ports:
    - name: http
      containerPort: 80
      protocol: TCP
    env:
    - name: JVM_OPTS
      value: "-Xms128m -Xms128m"
    resources:
      requests: 
        cpu: "100m"
        memory: "128Mi"
      limits:
        cpu: "200m"
        memory: "256Mi"
  restartPolicy: OnFailure
```

使用kubectl get pod -o wide 查看更加详细的信息



Pod 探针。一种监控技术，判断pod一些的运行状态

例如我们在Pod中配置了一个镜像，是一个微服务，当我们微服务因为一些原因服务挂掉过后，我们的pod是否还存在，怎么知道他存不存在呢？这里就要使用到探针。

livenessProbe：当我们创建了一个pod后，会对应创建一个探针来监控我们的镜像，当镜像挂掉后，对应的探针就会检查我们的资源清单中是否配置了restartPolicy相关的配置。

所以我们通过配置livenessProbe来进行配置相关的特性：

```shell
```





readinessProbe 

如果我们现在有一个pod，里面我们还需要做一些初始化的操作，在初始结束之前，我们不希望外界可以访问这个pod，这个时候我们就需要readinessProbe探针来监测我们的初始化服务是否有初始化完成，完成后才开启我们的pod，接收外部的流量





startupProbe 启动探针(判断pod是否是否已经) 只有当startupProbe，后面的探针才会起作用





探测方式

execAction： 在镜像中以命令的方式去探测，如果探测成功，则返回0

![image-20230828183306871](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230828183306871.png)



TCPSocketAction

通过tcp的形式发送网络请求看是否能够成功

![image-20230828183422651](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230828183422651.png)



HTTPGETAction

![image-20230828183455192](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230828183455192.png)





![image-20230828183522866](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230828183522866.png)













