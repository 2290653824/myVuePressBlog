

1. 实习中遇到了什么深刻的问题

聊到了数据库增量数据迁移的一些问题

2. 实习过程中收获了什么东西

技术方面、非技术方面

3. 面向对象的特征，多态项目中实际的应用
4. 面向对象的基本原则

其实就是设计模式的几大原则，我服了没答出来

5. 构造方法可以被重载吗 - 可以；构造方法可以被重写吗- 不能
6. abstract和static可以在同一个方法上被使用吗

> 在 Java 中，`abstract` 和 `static` 这两个关键字不能同时用于同一个方法。这是因为它们具有不同的语义和行为，导致它们无法同时出现在同一个方法声明中。
>
> - `abstract` 方法是指在父类中声明但没有实现的方法，要求子类必须提供具体的实现。抽象方法没有方法体，只有方法签名。抽象方法必须在抽象类中声明。
> - `static` 方法是指属于类而不是实例的方法。它们可以直接通过类名来调用，而无需先创建类的实例。静态方法通常用于实现与类本身相关的功能，而不涉及特定对象的状态。
>
> 因为抽象方法要求子类提供具体的实现，而静态方法是与类而非实例相关的，将这两者合并到同一个方法是没有实际意义的，也与它们各自的目的相违背。因此，在 Java 中，不能将 `abstract` 和 `static` 同时应用于同一个方法。



7. 实习的项目当中有没有使用到集合或者什么算法之类的。

8. 浏览器中输入一个网址，后续流程是怎么走的
9. 在网络传递过程中，mac地址扮演了怎么样的角色

> 在网络传递过程中，MAC 地址（Media Access Control 地址）扮演着重要的角色。MAC 地址是网络设备（如计算机、网络适配器、路由器等）网卡上的唯一标识符，用于在局域网（LAN）中识别设备。以下是 MAC 地址在网络传递过程中的几个关键角色：
>
> 1. **唯一标识设备**：每个网络设备都有一个唯一的 MAC 地址，它类似于身份证号码，用于在局域网中标识和区分不同的设备。这有助于确保数据包被正确地传送到目标设备。
> 2. **数据链路层寻址**：在 OSI 模型的数据链路层（第二层），数据帧是通过 MAC 地址进行寻址的。当数据从源设备发送到目标设备时，数据帧中包含了源设备和目标设备的 MAC 地址。网络设备通过比较目标 MAC 地址来判断是否接收这个数据帧。
> 3. **局域网内通信**：在同一局域网内，设备之间的通信是基于 MAC 地址的。当一个设备需要与另一个设备通信时，它可以将数据包发送到目标设备的 MAC 地址，而不必关心远程目标设备的 IP 地址。
> 4. **ARP 协议**：在 IP 地址到 MAC 地址的映射方面，ARP（Address Resolution Protocol）扮演着重要角色。当一个设备知道目标的 IP 地址但不知道其对应的 MAC 地址时，它会发送 ARP 请求广播，询问谁拥有特定 IP 地址的 MAC 地址。目标设备会回应这个请求，将其 MAC 地址发送给请求者，以便建立正确的映射关系。
>
> 总之，MAC 地址在局域网内的数据帧传递、设备识别和 ARP 协议中发挥着关键作用。但需要注意的是，在不同的局域网之间（不同的子网），通信是通过路由器和 IP 地址来进行的，而不是直接通过 MAC 地址。

没有答到在局域网内唯一标识一台设备。答了ARP协议

10. 对netty的了解。
11. 拆包和粘包是什么？怎么解决拆包和粘包的问题。

> 1. **拆包（Packet Splitting）**：拆包是指发送端将一次性的数据分割成多个小包进行发送，而接收端在接收数据时可能会将这些小包当作独立的消息进行处理。这可能导致接收端得到的数据包不完整，造成数据解析错误。
> 2. **粘包（Packet Pasting）**：粘包是指发送端将多个消息封装成一个大的数据包进行发送，接收端在接收数据时可能会将多个消息组合在一起，导致解析时出现混乱。
>
> 这些问题的产生是因为底层的 TCP 协议是面向流的，它负责将数据分割成合适的数据包并传输，但并不保证数据包与应用层消息的一一对应。
>
> 为了解决拆包和粘包问题，可以采取以下方法：
>
> 1. **定长消息**: 发送端在发送消息前，将消息固定长度填充，使得每个消息的长度都是固定的。接收端可以按照固定长度来解析消息。
> 2. **分隔符消息**: 发送端在消息之间插入特定的分隔符，接收端通过分隔符来识别消息的边界。这种方法需要选择一个不会在消息内容中出现的分隔符。
> 3. **消息长度字段**: 在消息头部添加一个字段，表示整个消息的长度。接收端首先读取长度字段，然后按照指定长度读取剩余的数据，从而精确地分割消息。
> 4. **应用层协议**: 在应用层设计专门的协议来管理消息的分割和合并，确保消息按照预定的格式进行传输。
> 5. **使用换行符**: 如果应用允许，可以在消息末尾添加换行符（例如 '\n'）作为分隔符，这在文本协议中比较常见。
> 6. **使用专门的库或框架**: 一些网络通信库或框架（例如 Netty）提供了解决拆包和粘包问题的机制，可以减轻开发人员的负担。
>
> 总之，解决拆包和粘包问题需要根据具体情况选择合适的方法，并在通信协议设计中充分考虑这些问题，以确保数据的正确传输和解析。

12. sleep(0) 有什么用

> Thread.Sleep(0)的作用，就是“**触发操作系统立刻重新进行一次CPU竞争**”。 竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。

https://developer.aliyun.com/article/37928

yiel:在Java中，Thread类中的yield()方法**用于将CPU 资源让给其他线程**。 当一个线程调用yield()方法时，它会暂停当前正在执行的任务并让出CPU资源，以便其他线程有机会执行。 如果没有其他线程需要执行，那么该线程将继续执行

所以sleep(0)和yield() 有什么区别？TODO



13. 实习或项目中有没有并发的场景

还需要打造 



14. volatile 关键字的作用？可以保证原子性吗？

>  `volatile` 关键字可以保证变量的可见性和有序性，但不能保证操作的原子性。在多线程环境下，多个线程可能同时访问和修改同一个 `volatile` 变量，而且 `volatile` 变量的修改不会被缓存，而是直接从主内存中读取或写入。
>
> 原子性是指一个操作是不可中断的，要么全部执行成功，要么全部不执行，没有中间状态。`volatile` 修饰的变量在读取和写入时不会发生线程切换或中断，但对于复合操作（例如递增操作）可能会发生竞态条件，导致不一致的结果。
>
> 如果需要确保某个操作的原子性，可以使用 `java.util.concurrent` 包中提供的原子类，比如 `AtomicInteger`、`AtomicLong` 等。这些原子类提供了一系列原子操作，可以保证在多线程环境下执行这些操作时不会发生竞态条件，从而保证原子性。
>
> 总结起来，`volatile` 可以保证可见性和有序性，但不足以保证复合操作的原子性。对于需要保证原子性的操作，应该使用适当的同步机制，如 `synchronized` 块或 `java.util.concurrent` 包中的原子类。

https://www.zhihu.com/question/329746124

15. 出现了bug，你有哪些思路来排查bug。





