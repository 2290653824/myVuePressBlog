 ### 记忆集 Remember Set

why 为什么用记忆集

- 跨带引用

老年代中的对象可能引用了新生代中的对象



那么在进行young gc时，我们通过gc roots在新生代中找到了对应需要保留的对象，而其他的对象可能部分是被老年代引用的，这些对象需要被保留，但是新生代的gc roots并没有扫描到。

解决方法：

1. 扫描老年代的对象，查看是否有跨带引用的对象（缺点：还需要对老年代进行扫描，效率太低）
2. 使用记忆集：在新生代这边的内存区域维护一个记忆集，这个记忆集中存放了老年代中跨带引用对象的引用，当进行gc roots标记时，记忆集中的对象也会开始寻找关联对象。



### 什么是卡表

卡表 Cardtable：jdk中记忆集的具体实现

卡表有两个概念 卡页、卡表

卡页：在老年代中没512byte字节为一个卡页，一些对象就分配在卡页中



卡表：年轻代维护的一个数组，里面存放对应卡页是否为脏页和对应的卡页起始位置。



当老年代分批对象时，一旦某一个卡页中出现了脏页，则会在年青代中卡表对应的节点置为1；



当进行垃圾年青代垃圾清楚时，扫描卡表检查是否有脏页，有的话，则对脏页进行扫描检查跨代引用

![image-20230811210810622](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230811210810622.png)





## G1垃圾回收器

>  G1 (Garbage-First)是一款面向服务器的垃圾收集器,**主要针对配备多颗处理器及大容量内存的机器**. 以极高概率满足**GC停顿时间要求的同时,还具备高吞吐量性能特征**.

### G1简介

放弃传统的垃圾回收的分代内存模型，而采用局部回收的思想

![image-20230811213513145](../../../90.%E5%85%B6%E4%BB%96/20.%E9%9D%A2%E8%AF%95/https%253A%252F%252F2290653824-github-io.oss-cn-hangzhou.aliyuncs.com%252Fimage-20230811213513145.png)

### Region

​	G1将Java堆划分为多个大小相等的独立区域（**Region**），JVM最多可以有2048个Region。一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M，当然也可以用参数"-XX:G1HeapRegionSize"手动指定Region大小，但是推荐默认的计算方式。



​	G1将Java堆划分为多个大小相等的独立区域（**Region**），JVM最多可以有2048个Region。一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M，当然也可以用参数"-XX:G1HeapRegionSize"手动指定Region大小，但是推荐默认的计算方式。G1保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。默认年轻代对堆内存的占比是5%，如果堆大小为4096M，那么年轻代占据200MB左右的内存，对应大概是100个Region，可以通过“-XX:G1NewSizePercent”设置新生代初始占比，在系统运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过“-XX:G1MaxNewSizePercent”调整。年轻代中的Eden和Survivor对应的region也跟之前一样，默认8:1:1，假设年轻代现在有1000个region，eden区对应800个，s0对应100个，s1对应100个。一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化。



​	G1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，**唯一不同的是对大对象的处理**，G1有专门分配大对象的Region叫**Humongous区**，而不是让大对象直接进入老年代的Region中。在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放入Humongous中，而且一个大对象如果太大，可能会横跨多个Region来存放。Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开销。Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。

### 回收流程

- **初始标记**（initial mark，STW）：暂停所有的其他线程，并记录下gc roots直接能引用的对象，**速度很快** ；
- **并发标记**（Concurrent Marking）：同CMS的并发标记
- **最终标记**（Remark，STW）：同CMS的重新标记
- **筛选回收**（Cleanup，STW）（这个过程中因为最短停顿时间没有被回收的垃圾，会在下一次在进行回收）

>  筛选回收阶段首先对各个Region的**回收价值和成本进行排序**，**根据用户所期望的GC停顿时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制定回收计划**，比如说老年代此时有1000个Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region(**Collection Set**，要回收的集合)，尽量把GC导致的停顿时间控制在我们指定的范围内。这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。不管是年轻代或是老年代，**回收算法主要用的是复制算法**，**将一个region中的存活对象复制到另一个region中，然后在清理掉第一个region，这种不会像CMS那样回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片**。(注意：CMS回收阶段是跟用户线程一起并发执行的，G1因为内部实现太复杂暂时没实现并发回收，不过到了Shenandoah就实现了并发收集，Shenandoah可以看成是G1的升级版本)【注意：这里的停顿时间包括了一次回收中的三个stw时间总和】



注意：G1也是准求的最少停顿时间，但是相应的吞吐量就会降低，因为对应会执行过多次垃圾回收。

![image-20230811220511304](C:/Users/zhengjian/AppData/Roaming/Typora/typora-user-images/image-20230811220511304.png)



**G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大（例如stw 20ms回收20M内存比回收1M内存价值更大，与某一个region中的存活对象的数目多少有关，因为存活对象需要通过复制算法到新的region中，这个过程比较好费时间）的Region(这也就是它的名字Garbage-First的由来)，比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收**。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率。



>  注意：最短的停顿时间不要设置的太小，例如默认200ms，但是手动设置为5ms，这样会导致一次垃圾回收无法回收足够的垃圾，很多垃圾逐渐积累到下一个阶段，最终会造成full gc甚至内存溢出

### 特点

