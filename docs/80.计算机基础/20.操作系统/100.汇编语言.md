## 一.前言

汇编语言是任何一种计算机的一种低级语言

不同的机器中汇编语言的指令集不同

通过汇编语言转换成机器后才能执行

不同平台之间不能进行移植

### 1.1 机器语言
机器语言：010101组成的数据集合

例如：机器指令：01010000 表示的汇编语言为(PUSH AX)

对应到物理层会有一个**电平脉冲**：

![image-20230814230526993](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230814230526993.png)



如果只有机器语言

1. 计算 S=768+12288+1280 ,
2. 表示机器码如下

![image-20230814230745744](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230814230745744.png)

3. 但是如果我们在输入的过程中，输入错误了，那找到对应的01哪儿错了就非常困难

![image-20230814230820173](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230814230820173.png)



- 错误难以查找
- 01难以编程



由此产生了汇编语言

- 汇编语言的主体是汇编指令
- 汇编指令和机器指令的差别在于指令的表示方法上。汇编指令是机器指令的一种更好记忆的书写格式



示例：

![image-20230814231114625](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230814231114625.png)

与人类语言更接近

汇编指令经过**编译器**可以成为机器指令



### 1.2 汇编语言的组成

1. 汇编指令（机器码的助记符）
2. 伪指令（由编译器执行）
3. 其他符号（由编译器识别）



汇编语言的核心是汇编指令，他决定了汇编语言的特性。



### 1.3 指令与数据

怎么区分汇编中表示的是指令还是数值

![image-20230814231446136](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230814231446136.png)

一串机器码的实际含义取决于当前的机器码处在的语境当中（程序还是数据中）



### 1.4 存储器

cpu要执行，就必须给他提供指令和数据，而指令和数据就储存在我们存储器中

**内存的作用仅次于CPU**，磁盘与内存不同，需要首先将磁盘上的数据存放到内存



存储单元



存储器被花费为若干个存储单元，每个存储丹单元从0开始编号。

![image-20230814232237404](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230814232237404.png)

每一个存储单元可以存储一个字节即8bit

除了以1B为单位，还可以用以下为单位

![image-20230814232411392](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230814232411392.png)



CPU想要对存储器中的数据进行读写，必须和外部器件（芯片）进行交互

- 存储单元的地址（地址信息）
- 器件的选择，读或写命令（控制信息）
- 读或写的数据（数据信息）



那么CPU是如何告诉芯片这些信息的呢？

总线：计算机中专门有连接CPU和其他芯片的导线，通常称为总线。

物理上：一根根导线的集合

逻辑上：地址总线、数据总线、控制总线

示例：

![image-20230814232941394](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230814232941394.png)

1. CPU通过地址总线告诉内存其要操作的是3号内存号
2. CPU通过控制总线发出要读的信息
3. CPU通过数据总线读取3号为的数据，并存放到pu的器件中



写的流程和读差不多。类比即可

例如cpu收到了对应的机器码，并执行相应的指令：
![image-20230814233259782](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230814233259782.png)



### 1.5 地址总线

- CPU是通过地址总线来指定存储单元的
- **地址总线上能够传输多少个不同的信息，CPU就可以对多少个存储单元进行寻址**

![image-20230814233553239](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230814233553239.png)

如果地址总线有10根，则可以寻址范围为 2^10

> ![image-20230814233647577](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230814233647577.png)



### 1.6 数据总线

- CPU与内存或其他器件之间的数据传输时通过数据总线来进行的



- 数据总线的宽度决定了CPU和外界的数据的传送速度



举例

向内存中写入数据89D8H：

![image-20230814233919353](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230814233919353.png)

一次传输1字节



![image-20230814233929232](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230814233929232.png)

一次传输两字节



### 1.7 控制总线

- CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。
- 有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。
- 所以，**控制总线的宽度决定了CPU对外部器件的控制能力。**

![image-20230814234235259](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230814234235259.png)

总结

- 地址总线的宽度决定了CPU的寻址能力;
- 数据总线的宽度决定了CPU与其它器件进行数据传送时的一次数据传送量;
- 控制总线宽度决定了CPU对系统中其它器件的控制能力。





