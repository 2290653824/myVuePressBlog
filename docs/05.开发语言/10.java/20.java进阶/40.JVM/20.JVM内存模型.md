---
title: JVM内存模型
date: 2023-01-15 12:51:27
permalink: /pages/c3e1fb/
categories:
  - java进阶
  - JVM
tags:
  - 
author: 
  name: xugaoyi
  link: https://github.com/xugaoyi
---
```
title: JVM内存模型
date: 2023-01-05 14:29:20
permalink: /pages/f913fb/
categories:
  - java进阶
  - JVM
tags:
  -
author:
  name: xugaoyi
  link: <https://github.com/xugaoyi>
```

## **JDK结构体系**

- 首先jdk包括jre和tools，其中jre就包含了我们开发当中用到的核心类库，还有非常重要的java虚拟机。另外tools就是我们经常用到的一些java工具，比如javac 等

## **java语言的跨平台性**

与jvm有关，我们在下载java的时候，会对应着不同的操作系统linux、window、mac等。这些不同的版本也对应着不同的虚拟机版本，其虚拟机版本调用的底层api也就不尽相同

## **JVM内存模型**

```
public class Math {
  public static final int initData = 666;

  public int compute() { //一个方法对应一块栈帧内存区域
    int a = 1;
    int b = 2;
    int c = (a + b) * 10;
    return c;
  }

  public static void main(String[] args) {
    Math math = new Math();
    math.compute();
  }

}
```

线程私有：

### ①程序计数器

记录每一个线程将要执行的指令的地址。执行引擎可以柑橘程序计数器执行相应的代码，并修改程序器指向下一条要执行的代码。当线程之间进行切换时，每个线程需要知道自己已经跑到哪条指令了，用于恢复上下文。

即 **记录指定地址**和**恢复上下文**

因为程序计数器永远记录的都是一个地址，所以不会出现OutOfMemery的异常

### ②虚拟机栈

生命周期和线程一样。

一个线程每执行一个方法，就对应着一次栈帧的压入，每次方法执行结束（包括异常）都会对应这一个栈帧的出栈。

栈帧中对应着4个区域：

- 局部变量表:存储方法中定义的局部变量,如方法参数、for循环变量等,这些变量在方法执行完后就会被销毁。局部变量表中可以存储8种基本数据类型和引用指针
- 操作数栈:用于执行操作数栈指令,如加、乘、取数组元素等。
- 动态链接:存储方法调用的过程地址,用于方法调用。

动态链接存储了方法调用过程所需的地址,用于方法调用。每次方法调用都需要在动态链接中找到方法的地址,然后执行相应的方法。实质就是将符号引用转化为直接引用。

- 方法出口:用于从方法中返回时,恢复到调用该方法的方法的执行点。

![image-20230317233829448](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230317233829448.png)

### ③本地方法栈

本地方法栈类似虚拟机栈类似，不过方法调用的是调用的本地方法。什么是本地方法:

本地方法指的是java代码中调用的使用其他语言(例如C/C++)实现的方法。这些方法的具体实现是依赖于特定平台的,并不跟java代码一样可以在不同平台之间进行跨平台执行。本地方法的执行依赖于本地平台的库,由本地方法栈来调用。

虚拟机栈和本地方法栈可能会出现哪些异常？

StackOverFlow：如果栈不允许动态扩容，当线程请求的栈深度达到栈的最大深度时，就会抛出该异常。

OutOfMemery：如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

线程公有：

### ④方法区

当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。



方法区的实现

在1.7之前使用的永久代，1.8后使用的是元空间

![](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedundefinedundefinedimage-20230318000606797.png)

Java虚拟机（JVM）中的永久代是用于存储类元数据的一块内存区域，例如类的名称、方法信息等。在早期的JVM版本中，永久代的大小是固定的，这可能导致内存溢出问题。此外，JVM中的永久代还存在垃圾回收效率低下等问题。

为了解决这些问题，从JDK8开始，JVM将永久代改为了元空间（Metaspace），这是一块动态大小的内存区域，可以根据应用程序的需要进行扩展和收缩。与永久代不同，元空间中的类元数据存储在本地内存中，而不是Java堆中，这可以提高垃圾回收的效率。

另外，元空间中的类元数据可以通过参数进行调整，例如最大大小、初始大小、垃圾回收策略等，这可以帮助开发人员更好地管理内存。总的来说，将永久代改为元空间是JVM的一项重大改进，可以提高JVM的性能和稳定性。

本地内存和java堆有区别吗，不是都用的计算机内存吗

Java堆是Java虚拟机管理的最大的一块内存区域，用于存储Java对象实例。Java堆的大小可以通过虚拟机参数进行设置，但是它受到Java虚拟机内存管理机制的控制，例如垃圾回收器。Java堆的一个特点是对象的生命周期是由垃圾回收器来管理和维护的。

本地内存（Native Memory）是Java虚拟机之外的内存区域，用于存储JVM本身和Java应用程序中使用的本地库（Native Libraries）的数据。本地库通常是使用本地语言编写的，例如C或C++，而不是Java。本地内存的大小通常是由操作系统和硬件限制的，但是可以通过Java Native Interface（JNI）等技术进行访问和管理。

总的来说，Java堆用于存储Java对象，而本地内存用于存储本地库的数据和JVM本身的数据。它们的管理方式和特点也不同，需要开发人员针对具体的应用场景进行调整和优化。



所以说元空间的类是不会被垃圾回收的？

是的，存储在元空间中的类元数据也不会被Java虚拟机的垃圾回收器所管理和回收，因为它们是在本地内存中分配和管理的，而不是在Java堆中。因此，如果应用程序动态地加载了大量的类或者应用程序的代码存在内存泄漏等问题，那么就可能导致元空间占用过多的本地内存而导致OOM。

为了避免这种情况，我们可以通过调整元空间的大小、限制类的加载数量和控制应用程序的内存使用等方式来优化内存使用。例如，可以使用JVM参数来限制元空间的最大大小，以避免元空间占用过多的本地内存。另外，可以优化代码结构，避免加载过多的类，减少内存使用量。总的来说，对于内存管理方面，需要开发人员有一定的经验和技巧，以确保应用程序能够稳定运行。



方法区由哪些部分组成？

![image-20230318003907675](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230318003907675.png)



![image-20230318003920809](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230318003920809.png)



什么是直接内存：

直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 `OutOfMemoryError` 错误出现。

JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

类似的概念还有 **堆外内存** 。在一些文章中将直接内存等价于堆外内，个人觉得不是特别准确。

堆外内存就是把内存对象分配在堆（新生代+老年代+永久代）以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。

### ⑤堆

几乎所有的对象都存放在堆中。

Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。



在堆中，一般采用的是分代收集算法。一般可以分为新生代(Eden、Survivor)和老年代。

![image-20230317235220520](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230317235220520.png)



对象在堆中分配的过程。

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

进入老年代的条件：

- 达到最大的晋升年龄，进入老年代
- 对象过大，直接进入老年代
- 当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值



可能出现的异常：

堆这里最容易出现的就是 `OutOfMemoryError` 错误，并且出现这种错误之后的表现形式还会有几种，比如：

1. **`java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`** ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
2. **`java.lang.OutOfMemoryError: Java heap space`** :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过`-Xmx`参数配置，若没有特别配置，将会使用默认值。



运行时介绍

javap看指令

jvisualVM看内存GC回收状态

STW 有机制原因

方法区不要设置空间太小，如果设置21M，war包又很大，那么可能会触发扩容机制，导致启动程序很慢





## 对象分配过程

### 对象的创建过程

#### Step1:类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

#### Step2:分配内存

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

**内存分配的两种方式** （补充内容，需要掌握）：

- 指针碰撞 ： 
  - 适用场合 ：堆内存规整（即没有内存碎片）的情况下。
  - 原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
  - 使用该分配方式的 GC 收集器：Serial, ParNew
- 空闲列表 ： 
  - 适用场合 ： 堆内存不规整的情况下。
  - 原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
  - 使用该分配方式的 GC 收集器：CMS

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。

**内存分配并发问题（补充内容，需要掌握）**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

#### Step3:初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

#### Step4:设置对象头

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

#### Step5:执行 init 方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。



### 对象的内存布局

在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**。

**Hotspot 虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。

**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。** 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。



### 对象的访问定位

建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：**使用句柄**、**直接指针**。

#### 句柄

如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。

![image-20230318212820690](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230318212820690.png)

#### 直接指针

如果使用直接指针访问，reference 中存储的直接就是对象的地址。

![image-20230318212850763](https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230318212850763.png)

这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。

