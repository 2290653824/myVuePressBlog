

 ## 在spring中怎么定义一个CustomScannerRegister？

在 Spring 中，您可以通过实现 `org.springframework.context.annotation.ImportBeanDefinitionRegistrar` 接口来定义一个自定义的扫描器注册器，从而向容器注册 bean。以下是一个简单的例子，展示如何实现这个接口来创建一个自定义的扫描器注册器：

```
javaCopy code
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;
import org.springframework.core.type.AnnotationMetadata;

public class CustomScannerRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
        // 在此处可以编写扫描逻辑，并使用 registry 注册 bean。
    }
}
```

在这个示例中，我们实现了 `ImportBeanDefinitionRegistrar` 接口，并重写了 `registerBeanDefinitions()` 方法，该方法接收两个参数：`AnnotationMetadata` 和 `BeanDefinitionRegistry`。在这个方法中，我们可以编写扫描逻辑，并使用 `BeanDefinitionRegistry` 实例注册 bean。例如，您可以使用 `ClassPathBeanDefinitionScanner` 扫描特定的包，并将扫描到的 bean 注册到容器中：

```
javaCopy code
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.context.annotation.ClassPathBeanDefinitionScanner;
import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;
import org.springframework.core.type.AnnotationMetadata;

public class CustomScannerRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
        ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry);
        scanner.scan("com.example.custompackage");
    }
}
```

这个示例中，我们使用了 `ClassPathBeanDefinitionScanner` 扫描了包路径为 `com.example.custompackage` 的所有类，并将扫描到的 bean 注册到容器中。请注意，在您的项目中使用时，您需要修改包路径和扫描逻辑来适应您的项目。





### mybatis举例

这个接口的使用和@import注解一起使用。我们可以看看mybatis整合springboot中是如何实现这个ImportBeanDefinitionRegistrar

在使用@MapperScann() 意思是扫描指定的dao接口路径，我们来看看这个注解是如何使用的

```java
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
@Documented
@Import({MapperScannerRegistrar.class})
@Repeatable(MapperScans.class)
public @interface MapperScan {
}
```

我们可以看到这里使用@Import注解，里面有一个类叫做MapperScannerRegistrar.class

- 首先看看@Import注解，这个注解的作用如下·所示

@Import注解的作用是给容器中导入组件，回顾下我们给容器中注入组件的方式，可以通过Spring的xml配置方式，也可以通过注解，如`@Component`等，也可以通过java配置类的方式给容器中导入注解，今天来介绍另一个注解，其作用也是给容器中导入组件。

也即是这个注解将我们MapperScannerRegistrar注入到我们的容器中。

- 我们再来看看这个MapperScannerRegistrar对象

```JAVA
public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware {

  private ResourceLoader resourceLoader;

  /**
   * {@inheritDoc}
   */
  @Override
  public void setResourceLoader(ResourceLoader resourceLoader) {
    this.resourceLoader = resourceLoader;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
    // 获取了MapperScan注解上的属性
    AnnotationAttributes mapperScanAttrs = AnnotationAttributes
        .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));
    if (mapperScanAttrs != null) {
      registerBeanDefinitions(mapperScanAttrs, registry);
    }
  }

  void registerBeanDefinitions(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry) {
	// ClassPathMapperScanner继承了spring的扫描器ClassPathBeanDefinitionScanner
    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

    // this check is needed in Spring 3.1
    Optional.ofNullable(resourceLoader).ifPresent(scanner::setResourceLoader);

    Class<? extends Annotation> annotationClass = annoAttrs.getClass("annotationClass");
    if (!Annotation.class.equals(annotationClass)) {
      scanner.setAnnotationClass(annotationClass);
    }

    Class<?> markerInterface = annoAttrs.getClass("markerInterface");
    if (!Class.class.equals(markerInterface)) {
      scanner.setMarkerInterface(markerInterface);
    }

    Class<? extends BeanNameGenerator> generatorClass = annoAttrs.getClass("nameGenerator");
    if (!BeanNameGenerator.class.equals(generatorClass)) {
      scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass));
    }

    Class<? extends MapperFactoryBean> mapperFactoryBeanClass = annoAttrs.getClass("factoryBean");
    if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) {
      scanner.setMapperFactoryBeanClass(mapperFactoryBeanClass);
    }

    scanner.setSqlSessionTemplateBeanName(annoAttrs.getString("sqlSessionTemplateRef"));
    scanner.setSqlSessionFactoryBeanName(annoAttrs.getString("sqlSessionFactoryRef"));

    List<String> basePackages = new ArrayList<>();
    basePackages.addAll(
        Arrays.stream(annoAttrs.getStringArray("value"))
            .filter(StringUtils::hasText)
            .collect(Collectors.toList()));

	// 给扫描器增加扫描路径
    basePackages.addAll(
        Arrays.stream(annoAttrs.getStringArray("basePackages"))
            .filter(StringUtils::hasText)
            .collect(Collectors.toList()));

    basePackages.addAll(
        Arrays.stream(annoAttrs.getClassArray("basePackageClasses"))
            .map(ClassUtils::getPackageName)
            .collect(Collectors.toList()));

    scanner.registerFilters();
    // 开始扫描
    scanner.doScan(StringUtils.toStringArray(basePackages));
  }

  /**
   * A {@link MapperScannerRegistrar} for {@link MapperScans}.
   * @since 2.0.0
   */
  static class RepeatingRegistrar extends MapperScannerRegistrar {
    /**
     * {@inheritDoc}
     */
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
        BeanDefinitionRegistry registry) {
      AnnotationAttributes mapperScansAttrs = AnnotationAttributes
          .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScans.class.getName()));
      if (mapperScansAttrs != null) {
        Arrays.stream(mapperScansAttrs.getAnnotationArray("value"))
            .forEach(mapperScanAttrs -> registerBeanDefinitions(mapperScanAttrs, registry));
      }
    }
  }

}


```

同时我们会发现上面的类经常会和以下的类结合在一起`ClassPathBeanDefinitionScanner`:



#### ClassPathBeanDefinitionScanner有什么用

ClassPathBeanDefinitionScanner是Spring框架中的一个组件，主要用于扫描指定路径下的类文件，自动将符合条件的类注册为Spring容器中的BeanDefinition。

具体来说，ClassPathBeanDefinitionScanner通常用于以下情况：

1. 扫描指定包路径下的类文件，将其转换为BeanDefinition注册到Spring容器中，以便在需要时使用。
2. 扫描类文件中的注解，将带有特定注解的类自动注册为BeanDefinition，简化了手动配置的过程。
3. 扫描指定路径下的XML文件，将其中定义的Bean自动注册到Spring容器中，简化了手动配置的过程。

使用ClassPathBeanDefinitionScanner可以大大减少手动配置Bean的工作量，提高代码的开发效率和可维护性。同时，它也使得开发人员可以更加专注于业务逻辑的实现，而不是过多关注框架相关的细节。

#### ClassPathBeanDefinitionScanner案例

在spring中我自定义了一个注解，让我想让spring能够自动扫描对应的包，然后将包下面使用了自定义注解的类加载到spring ioc中。

要使用ClassPathBeanDefinitionScanner将使用自定义注解的类注册到Spring容器中，可以按照以下步骤进行：

1. 定义自定义注解

可以使用Java的元注解（@Target和@Retention）来定义一个注解，并添加相应的属性，例如：

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String value() default "";
}
```

2. 创建扫描器并设置过滤器（重点）

创建一个ClassPathBeanDefinitionScanner实例，并设置TypeFilter，以便仅扫描带有自定义注解的类，例如：

```java
ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(applicationContext);
TypeFilter myAnnotationFilter = new AnnotationTypeFilter(MyAnnotation.class);
scanner.addIncludeFilter(myAnnotationFilter);
```

3. 扫描指定的包路径

调用scanner的scan()方法，指定要扫描的包路径，例如：

```java
scanner.scan("com.example");
```

在这个例子中，将扫描com.example包下的所有类文件，自动将带有@MyAnnotation注解的类注册为Spring的BeanDefinition。

4. 在Spring容器中使用Bean

完成上述步骤后，使用带有@MyAnnotation注解的类的实例就可以在Spring容器中被自动注入或获取。

总的来说，通过定义自定义注解、创建扫描器并设置过滤器、扫描指定的包路径等步骤，可以使用ClassPathBeanDefinitionScanner将使用自定义注解的类注册到Spring容器中。这样可以大大提高开发效率和可维护性。



如果在spring中配置了

```xml
<context:component-scan base-package="com.example.demo" />
```

那么在ioc容器的初始化阶段就会调用beanFactoryPostProcessor阶段，就会采用classPathBeanDefinitionScanner进行包扫描，并将符合过滤条件的类注册到IOC容器内。就类似于mybatis的mapper注册器同样是继承ClassPastBeanDefinitionScanner，来进行对应路径下的包的扫描和definition的注册。



那么我们会什么还会使用ImportBeanDefinitionRegistrar呢？

原因如下：

如果你只需要自动将使用自定义注解的类加载到Spring容器中，而不需要对这些类进行其他的处理，那么就不需要使用ImportBeanDefinitionRegistrar。

ImportBeanDefinitionRegistrar接口是用于动态注册BeanDefinition的高级扩展点，它允许在BeanDefinition注册之前对BeanDefinition进行一些特殊处理，例如：修改BeanDefinition的属性、增加额外的元数据等等。它的主要作用是在@Configuration类中，通过实现ImportBeanDefinitionRegistrar接口，动态地向容器中注册BeanDefinition。

在使用自定义注解注册Bean时，如果只需要简单地将使用自定义注解的类加载到Spring容器中，而不需要对这些类进行特殊处理，那么就不需要使用ImportBeanDefinitionRegistrar接口。使用ClassPathBeanDefinitionScanner就足够了。

当然，如果你需要对自定义注解的类进行特殊处理，例如：根据注解的属性修改BeanDefinition的属性，那么可以考虑使用ImportBeanDefinitionRegistrar接口来完成这些操作。需要注意的是，这种方式比较复杂，需要实现一些接口，编写一些代码，因此只有在必要的情况下才需要使用。







那么实现这个接口有什么用呢？

通过@Import({ImportBeanDefinitionRegistrar.class})，可以让spring启动过程创建beanDefinition时调用registerBeanDefinitions方法，传入BeanDefinitionRegistry注册器，那么我们就可以自己设置规则，来往spring里面注册beanDefinition，从而做到往ioc容器中注册bean的过程

简单的说ImportBeanDefinitionRegistrar，可以让我们自己注册bean到spring ioc容器中

## 什么是AnnotationAttributes和AnnotationMetadata

AnnotationAttributes是Spring框架提供的一个工具类，用于方便地获取和操作注解中的属性。它提供了一些常用的方法，如获取字符串、布尔、整数等类型的属性值，也可以通过getAttribute方法获取Object类型的属性值，还可以判断注解中是否存在某个属性等。

AnnotationAttributes通常用于通过反射获取注解的属性及其值。在Spring中，通过AnnotationMetadata接口获取注解的属性及其值，它的实现类StandardAnnotationMetadata中提供了一个getAnnotationAttributes方法，用于获取指定注解的AnnotationAttributes对象。

AnnotationAttributes使得使用注解时更加方便，可以通过AnnotationAttributes对象获取注解中的属性值，并可以直接用于构建BeanDefinition等操作。同时，AnnotationAttributes提供了类型安全的访问方法，能够防止类型转换错误导致的异常。



两者有什么区别呢？

AnnotationMetadata和AnnotationAttributes是Spring框架中用于处理注解的两个重要接口，它们的区别如下：

1. AnnotationMetadata是一个接口，它提供了访问类或方法上的注解及其属性的方法，可以获取注解的名称、属性及其值，还可以判断是否存在某个注解。AnnotationAttributes是AnnotationMetadata中的一个子接口，它提供了获取和操作注解属性的方法，可以获取注解属性的值、判断是否存在某个属性等。
2. AnnotationMetadata通常用于获取注解的信息，例如：获取注解的名称、类型、属性值等。AnnotationAttributes则用于获取和操作注解的属性，例如：获取属性的值、判断属性是否存在、修改属性的值等。
3. AnnotationMetadata提供了获取注解类型的方法，可以获取指定名称的注解类型，以及类或方法上所有注解的类型。AnnotationAttributes则没有获取注解类型的方法，它只能获取指定注解中的属性。

综上所述，AnnotationMetadata和AnnotationAttributes在处理注解时具有不同的功能和用途，AnnotationMetadata用于获取注解信息，而AnnotationAttributes用于获取和操作注解的属性。在Spring框架中，通常先使用AnnotationMetadata获取指定类或方法上的注解，再使用AnnotationAttributes获取注解的属性。



## maven中scope标签的含义

在 Maven 的依赖管理中，`scope` 标签用于指定依赖项在特定阶段的可见性和可用性。`scope` 可以设置为以下几个值：

- `compile`：默认值。依赖项在编译、测试和运行时均可用。
- `provided`：依赖项在编译和测试时可用，但在运行时由运行环境提供。例如，Servlet API 就是一个 `provided` 依赖项，因为它由 Web 容器提供。
- `runtime`：依赖项在测试和运行时可用，但在编译时不可用。例如，JDBC 驱动程序就是一个 `runtime` 依赖项，因为它只需要在运行时才需要。
- `test`：依赖项仅在测试时可用，不会在编译或运行时包含在项目中。
- `system`：依赖项类似于 `provided`，但需要手动提供 `jar` 文件的路径。
- `import`：仅用于 `<dependencyManagement>` 部分，用于导入其他 Maven 项目的依赖管理信息。

通过使用 `scope` 标签，可以使 Maven 知道哪些依赖项是必需的，哪些是可选的，以及在不同的构建阶段哪些依赖项是需要的。这有助于管理项目的依赖项，确保只有必需的依赖项被包含在构建中，从而减少项目的大小和复杂性。



### 一些常用的工具类

RuntimeUtil

```java
public class RuntimeUtil {

    /**
     * 获取当前cpu的数量
     * @return
     */
    public static int cpus(){
        return Runtime.getRuntime().availableProcessors();
    }
}
```





### bean的生命周期

在 Spring 中，Bean 的生命周期可以分为以下阶段：

1. 实例化（Instantiation）：Spring 根据配置文件中的信息，使用 Bean 工厂创建一个 Bean 的实例。
2. 属性赋值（Populating Properties）：Spring 将配置文件中的属性值和 Bean 的属性值进行绑定，也就是依赖注入。
3. 初始化（Initialization）：在 Bean 实例化完成并完成属性赋值之后，Spring 会调用 Bean 的初始化方法。Bean 可以通过实现 InitializingBean 接口或者在配置文件中指定 init-method 来定义初始化方法。
4. 使用（In Use）：Bean 可以被使用了。
5. 销毁（Destruction）：当 Bean 不再需要时，Spring 会调用 Bean 的销毁方法。Bean 可以通过实现 DisposableBean 接口或者在配置文件中指定 destroy-method 来定义销毁方法。

需要注意的是，只有在通过 Spring 容器获取 Bean 时，Bean 才会经过完整的生命周期，如果通过 new 关键字或其他方式创建 Bean，Spring 就无法控制 Bean 的生命周期。

此外，Spring 还提供了许多扩展 Bean 生命周期的方式，例如 BeanPostProcessor 接口和 BeanFactoryPostProcessor 接口等，它们可以在 Bean 的实例化和初始化过程中进行一些自定义的操作。



### 那么ImportBeanDefinitionRegistrar是处于哪一个阶段呢

ImportBeanDefinitionRegistrar 属于 Spring Bean 的注册阶段，而不是 Bean 的生命周期阶段。

在 Spring 中，Bean 的注册阶段是在 Bean 的实例化、属性赋值和初始化之前的一个阶段，通过 BeanDefinitionRegistry 接口向 Spring 容器中注册 Bean 定义，包括 Bean 的名称、类型、作用域、依赖关系等信息。这个阶段可以通过实现 BeanDefinitionRegistryPostProcessor 接口来进行自定义操作，例如修改或添加 Bean 的定义。

ImportBeanDefinitionRegistrar 接口是 BeanDefinitionRegistryPostProcessor 接口的子接口，它可以在注册 Bean 的同时，动态地注册其他的 Bean 定义。通常情况下，ImportBeanDefinitionRegistrar 接口是用来实现条件化注册 Bean 的场景，例如根据配置文件中的条件动态地注册一些 Bean。

需要注意的是，ImportBeanDefinitionRegistrar 接口的实现类会在 Bean 的注册阶段被调用，而不是 Bean 的生命周期阶段。在实现 ImportBeanDefinitionRegistrar 接口时，不能对已经存在的 Bean 进行修改或添加，否则会抛出异常。

在spring的启动过程中ImportBeanDefinitionRegistrar的registerBeanDefinitions方法只会调用一次，annotationMetadata可以获取注解的元信息





### 实现BeanPostProcessor有什么用？

BeanPostProcessor 接口是 Spring 框架中用于对 Bean 进行后置处理的一个扩展点，它可以在 Bean 的初始化前后对 Bean 进行一些自定义操作。BeanPostProcessor 接口属于 Bean 的初始化阶段，也就是 Bean 生命周期中的第三个阶段。

在 Bean 的初始化阶段，Spring 容器会调用实现了 BeanPostProcessor 接口的类的 postProcessBeforeInitialization() 方法，在 Bean 初始化之前对 Bean 进行自定义的操作。然后，Spring 容器会调用 Bean 的初始化方法（例如通过 @PostConstruct 注解指定的方法），完成 Bean 的初始化。最后，Spring 容器会调用实现了 BeanPostProcessor 接口的类的 postProcessAfterInitialization() 方法，在 Bean 初始化之后对 Bean 进行自定义的操作。

需要注意的是，BeanPostProcessor 接口中定义的方法会被所有的 Bean 实例共享，也就是说，如果一个 Bean 实现了 BeanPostProcessor 接口，那么它的 postProcessBeforeInitialization() 和 postProcessAfterInitialization() 方法会被所有的 Bean 实例调用，包括它自己。因此，在实现 BeanPostProcessor 接口时，需要判断当前处理的 Bean 是否是需要进行处理的目标 Bean。例如，可以通过 Bean 的名称、类型、注解等来判断当前 Bean 是否需要进行后置处理。

在 BeanPostProcessor 接口中的 postProcessAfterInitialization() 方法中，参数含义如下：

- Object bean：当前正在进行后置处理的 Bean 实例。
- String beanName：当前正在进行后置处理的 Bean 的名称。

这两个参数的作用分别是获取正在进行后置处理的 Bean 实例和 Bean 的名称，开发者可以在这个方法中对 Bean 进行自定义的后置处理，例如对 Bean 进行动态代理、AOP 切面等操作。

实现 BeanPostProcessor 接口的方式如下：

```java
public class MyBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        // 在 Bean 初始化之前进行自定义操作
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        // 在 Bean 初始化之后进行自定义操作
        return bean;
    }
}
```

在这个实现中，我们可以在 postProcessAfterInitialization() 方法中对 Bean 进行一些自定义的操作。例如，我们可以对某个 Bean 进行动态代理，以实现 AOP 切面的功能：

```java
public class MyBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if (bean instanceof UserService) {
            // 对 UserService 进行动态代理，以实现 AOP 切面的功能
            ProxyFactory proxyFactory = new ProxyFactory();
            proxyFactory.setTarget(bean);
            proxyFactory.addAdvice(new MyAdvice());
            return proxyFactory.getProxy();
        }
        return bean;
    }
}
```

在这个实现中，我们判断当前的 Bean 是否是 UserService 类型，如果是，则对该 Bean 进行动态代理，并将代理后的 Bean 实例返回，以实现 AOP 切面的功能。其他类型的 Bean 则不进行处理，直接返回原始的 Bean 实例。



### 那么aop是怎么和beanPostProcessor结合起来的呢？

Spring 中的面向切面（AOP）功能是通过 BeanPostProcessor 接口实现的，但它并不仅仅是通过 BeanPostProcessor 接口实现的。

在 Spring 中，实现 AOP 功能有多种方式，其中最常见的方式是使用 AspectJ 注解和 Spring AOP 配置，这两种方式都可以实现 AOP 功能，但它们的实现原理是不同的。

使用 AspectJ 注解时，需要使用 AspectJ 提供的注解，例如 @Aspect、@Before、@After 等，Spring 容器会扫描带有这些注解的类，并自动生成代理类，将代理类应用到目标 Bean 上，从而实现 AOP 功能。

使用 Spring AOP 配置时，需要在 Spring 配置文件中定义切面、切入点、通知等元素，Spring 容器会根据这些元素生成代理类，并将代理类应用到目标 Bean 上，从而实现 AOP 功能。

在实现 AOP 功能时，BeanPostProcessor 接口主要用于对目标 Bean 进行增强操作，例如对目标 Bean 进行动态代理，以实现 AOP 切面的功能。但 BeanPostProcessor 接口并不是实现 AOP 的必需品，开发者可以使用其他方式来实现 AOP 功能，例如使用 AspectJ 注解或 Spring AOP 配置等。





### java中的随机数

在 Java 中，Random 类是用于生成随机数的类，可以使用它来生成伪随机数。

要使用 Random 类生成随机数，可以按照以下步骤进行操作：

1. 创建 Random 对象。可以使用无参数构造函数来创建 Random 对象，也可以使用带有种子参数的构造函数来创建 Random 对象。如果不指定种子参数，则默认使用当前时间作为种子。

```java
Random random = new Random(); // 创建 Random 对象
```

2. 调用 Random 对象的方法来生成随机数。Random 类提供了多种方法来生成不同类型的随机数，例如生成整数、浮点数、布尔值等。

```java
int randomInt = random.nextInt(100); // 生成 [0, 100) 之间的随机整数
double randomDouble = random.nextDouble(); // 生成 [0.0, 1.0) 之间的随机浮点数
boolean randomBoolean = random.nextBoolean(); // 生成随机布尔值
```

3. 根据需要重复步骤 2 来生成多个随机数。

```java
int[] randomInts = new int[10];
for (int i = 0; i < 10; i++) {
    randomInts[i] = random.nextInt(100);
}
```

需要注意的是，Random 类生成的随机数是伪随机数，它们是根据某个算法计算出来的，而不是真正的随机数。如果需要更高质量的随机数，可以使用 java.security.SecureRandom 类来生成随机数。此外，还可以使用第三方库，例如 Apache Commons Math 库或 Google Guava 库，来生成更高质量的随机数。



### 为什么是伪随机数

伪随机数（Pseudo-Random Number）是由计算机程序生成的数值序列，看起来像是随机产生的数值序列，但实际上它们是由一个固定的算法计算出来的，因此不是真正的随机数。

在计算机科学中，真正的随机数是很难实现的，因为计算机是一台确定性的机器，它必须按照给定的算法执行指令。因此，计算机程序生成的数值序列通常是伪随机数，即看起来像是随机产生的数值序列，但实际上是由一个固定的算法计算出来的。这个算法称为随机数生成器（Random Number Generator，简称 RNG）。

由于伪随机数是由一个固定的算法计算出来的，因此它们具有以下特点：

1. 可重复性：由于伪随机数是由一个固定的算法计算出来的，因此如果使用相同的算法和种子，就会生成相同的数值序列。
2. 周期性：伪随机数的数值序列是有限的，当计算机执行的次数达到一定数量级时，数值序列就会重复。
3. 随机性：虽然伪随机数不是真正的随机数，但是它们具有很高的随机性，能够满足绝大多数应用场景的要求。

在实际应用中，伪随机数广泛用于模拟和加密等领域。如果需要更高质量的随机数，可以使用真正的随机数源，例如物理随机数源，但是这通常需要特殊的硬件设备和算法支持。







































